{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fundset-evm-settlement-layer",
  "type": "registry:item",
  "title": "fundset-evm-settlement-layer",
  "description": "fundset-evm-settlement-layer",
  "registryDependencies": [
    "https://fundset.vercel.app/r/fundset-core.json"
  ],
  "files": [
    {
      "path": "../evm/contracts/contracts/DiamondProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { SolidStateDiamond } from '@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol';\n\ncontract DiamondProxy is SolidStateDiamond {}\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/contracts/DiamondProxy.sol"
    },
    {
      "path": "../evm/contracts/ignition/modules/DiamondProxy.ts",
      "content": "import { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\nexport const DiamondProxyModule = buildModule('DiamondProxyModule', m => {\n  const diamondProxy = m.contract('DiamondProxy');\n\n  return { diamondProxy };\n});\n\nexport default DiamondProxyModule;\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/ignition/modules/DiamondProxy.ts"
    },
    {
      "path": "../evm/contracts/test/DiamondProxy.ts",
      "content": "import { describe, it } from 'node:test';\nimport { network } from 'hardhat';\n// We don't have Ethereum specific assertions in Hardhat 3 yet\nimport assert from 'node:assert/strict';\nimport DiamondProxyModule from '../ignition/modules/DiamondProxy.ts';\nimport { toFunctionSelector, WriteContractErrorType, zeroAddress } from 'viem';\nimport CounterVersionsModule from '../ignition/modules/CounterVersions.ts';\nimport { DIAMOND_ACTIONS } from '../types/diamond-action.ts';\n\ndescribe('DiamondProxy', async function () {\n  const { viem, ignition } = await network.connect();\n\n  it('should allow to increment the counter with V1 and V2 after attaching them to the diamond proxy', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV1, counterV2 } = await ignition.deploy(CounterVersionsModule);\n\n    const selectorsV1 = counterV1.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    // attach Counter V1\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV1.address, selectors: selectorsV1 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV1 = await viem.getContractAt('CounterV1', diamondProxy.address);\n    assert.equal(await diamondWithCounterV1.read.x(), 0n);\n    await diamondWithCounterV1.write.inc();\n    assert.equal(await diamondWithCounterV1.read.x(), 1n);\n\n    // Try running V2 before attaching, should fail\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await assert.rejects(diamondWithCounterV2.write.incBy([10n]), (err: WriteContractErrorType) =>\n      err.message.includes('Proxy__ImplementationIsNotContract()'),\n    );\n\n    // attach Counter V2\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    // should work now\n    await diamondWithCounterV2.write.incBy([10n]);\n    assert.equal(await diamondWithCounterV1.read.x(), 11n);\n  });\n\n  it('should allow to increment the counter per address', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV2 } = await ignition.deploy(CounterVersionsModule);\n    const [walletClient] = await viem.getWalletClients();\n\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await diamondWithCounterV2.write.incByAddress([10n]);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([walletClient.account.address]), 10n);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([zeroAddress]), 0n);\n  });\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/test/DiamondProxy.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/index.tsx",
      "content": "'use client';\n\nimport { useMemo } from 'react';\nimport * as viem from 'viem';\nimport * as chains from 'wagmi/chains';\nimport { type Chain } from 'wagmi/chains';\nimport { createConfig, WagmiProvider } from 'wagmi';\nimport type { EvmSettlementLayerConfig } from './config.type';\n\nexport * from './config.type';\nexport * from './connectors/web3auth';\n\nimport { createContext, useContext } from 'react';\n\nexport const EvmChainConfigsContext = createContext<\n  EvmSettlementLayerConfig['chainConfigs'] | null\n>(null);\n\nexport const useEvmChainConfigs = () => {\n  const config = useContext(EvmChainConfigsContext);\n  if (!config) {\n    throw new Error('EvmChainConfigsContext not found');\n  }\n  return config;\n};\n\nexport const EvmChainConfigsProvider = ({\n  children,\n  config,\n}: React.PropsWithChildren<{\n  config: EvmSettlementLayerConfig['chainConfigs'];\n}>) => {\n  return (\n    <EvmChainConfigsContext.Provider value={config}>{children}</EvmChainConfigsContext.Provider>\n  );\n};\n\nconst EvmSettlementLayerProvider = ({\n  children,\n  ...props\n}: React.PropsWithChildren<{ config: EvmSettlementLayerConfig }>) => {\n  const wagmiConfig = useMemo(() => {\n    const configChains = props.config.chainConfigs.map(chain =>\n      Object.values(chains).find(c => c.id === chain.chainId),\n    );\n\n    if (configChains.length === 0) {\n      throw new Error(\n        `Chains [${props.config.chainConfigs.map(c => c.chainId).join(', ')}] not found`,\n      );\n    }\n\n    const transports = props.config.chainConfigs.reduce(\n      (acc, chain) => ({\n        ...acc,\n        [chain.chainId]: viem.http(chain.rpcUrl, {\n          retryCount: 5,\n          retryDelay: 200,\n          batch: { wait: 100 },\n        }),\n      }),\n      {} as Record<number, viem.HttpTransport<undefined, false>>,\n    );\n\n    return createConfig({\n      chains: configChains as unknown as readonly [Chain, ...Chain[]],\n      transports,\n      ssr: true,\n      multiInjectedProviderDiscovery: true,\n      pollingInterval: 1000,\n    });\n  }, [props.config.chainConfigs]);\n\n  return (\n    <WagmiProvider config={wagmiConfig}>\n      <EvmChainConfigsProvider config={props.config.chainConfigs}>\n        {children}\n      </EvmChainConfigsProvider>\n    </WagmiProvider>\n  );\n};\n\nexport default EvmSettlementLayerProvider;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/index.tsx"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts",
      "content": "'use client';\n\nimport { useChainId, useConfig, useWalletClient } from 'wagmi';\nimport { SettlementLayer } from 'fundset/settlement-layer';\nimport { useMemo } from 'react';\nimport { buildCounterModule } from './modules/counter';\nimport { EvmChainModules, EvmModule } from './config.type';\nimport * as chains from 'wagmi/chains';\nimport { useEvmChainConfigs } from '.';\n\nexport const useEvmSettlementLayer = () => {\n  const evmChainConfigs = useEvmChainConfigs();\n  const { data: walletClient } = useWalletClient();\n  const config = useConfig();\n  const chainId = useChainId();\n\n  const evmModules = useMemo(() => {\n    return evmChainConfigs.reduce((acc, chainConfig) => {\n      acc[chainConfig.chainId] = {\n        proxyAddress: chainConfig.proxyAddress,\n        contracts: chainConfig.modules.reduce(\n          (contractsAcc, module) => {\n            if ('contracts' in module) {\n              module.contracts.forEach(contract => {\n                Object.entries(contract).forEach(([key, value]) => {\n                  if (key === 'id' || value === null) {\n                    return;\n                  }\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  (contractsAcc as any)[key] = value as `0x${string}`;\n                });\n              });\n            }\n            return contractsAcc;\n          },\n          {} as EvmModule['contracts'],\n        ),\n      };\n      return acc;\n    }, {} as EvmChainModules);\n  }, [evmChainConfigs]);\n\n  const evmSettlementLayer: SettlementLayer = useMemo(() => {\n    const chain = Object.values(chains).find(c => c.id === chainId) as chains.Chain;\n\n    const evmModule = evmModules[chainId];\n    if (!evmModule) {\n      throw new Error(`Evm module not found for chainId: ${chainId}`);\n    }\n\n    return {\n      name: 'evm',\n      ...buildCounterModule({\n        evmModule,\n        chain,\n        walletClient,\n        config,\n      }),\n    };\n  }, [walletClient, evmModules, chainId, config]);\n\n  return evmSettlementLayer;\n};\n\nexport default useEvmSettlementLayer;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/env.ts",
      "content": "import { createEnv } from '@t3-oss/env-nextjs';\nimport { z } from 'zod';\n\nexport const evmSettlementLayerEnv = () =>\n  createEnv({\n    client: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: z.string().optional(),\n    },\n    experimental__runtimeEnv: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: process.env.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID,\n    },\n    emptyStringAsUndefined: true,\n  });\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/env.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/config.type.ts",
      "content": "import { FundsetSettlementLayer } from '@/payload-types';\n\nexport type EvmSettlementLayerConfig = Extract<\n  NonNullable<FundsetSettlementLayer['settlementLayer']>[number],\n  { type: 'evm' }\n>;\n\nexport type EvmModule = {\n  proxyAddress: string;\n  contracts: EvmContracts;\n};\n\nexport type EvmChainModules = Record<number, EvmModule>;\n\ntype ModulesWithContracts = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { contracts: object }\n>;\n\nexport type EvmContracts = ModulesWithContracts extends infer M\n  ? M extends { contracts: infer C }\n    ? C extends Array<infer T>\n      ? Omit<T, 'id'>\n      : never\n    : never\n  : never;\n\nexport type EvmAccountAbstractionModule = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { blockType: 'evm-aa-module' }\n>;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/config.type.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/index.ts",
      "content": "import type { Config } from 'payload';\nimport { EvmSettlementLayer } from './blocks/EvmSettlementLayer';\nimport { seed } from './seed';\n\nexport const evmSettlementLayerPlugin =\n  () =>\n  (config: Config): Config => {\n    config.globals ??= [];\n\n    // append the postgres option to the settlement layer type field\n    const fundsetSettlementLayer = config.globals.find(g => g.slug === 'fundset-settlement-layer');\n\n    if (!fundsetSettlementLayer) {\n      throw new Error(\n        'fundsetSettlementLayer not found, run fundsetBasePlugin before postgresSettlementLayerPlugin',\n      );\n    }\n\n    const settlementLayerTypeField = fundsetSettlementLayer.fields.find(\n      f => f.type === 'blocks' && f.name === 'settlementLayer',\n    )!;\n\n    if (settlementLayerTypeField.type === 'blocks') {\n      settlementLayerTypeField.blocks.push(EvmSettlementLayer);\n    }\n\n    const defaultOnInit = config.onInit;\n\n    config.onInit = async payload => {\n      await defaultOnInit?.(payload);\n\n      const { evmSettlementLayerEnv } = await import('@/_fundset/settlement-layer/evm/env');\n      evmSettlementLayerEnv();\n\n      if (process.env.NODE_ENV === 'development') {\n        await seed(payload);\n      }\n    };\n\n    return config;\n  };\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/seed.ts",
      "content": "import { BasePayload } from 'payload';\nimport { entryPoint07Address } from 'viem/account-abstraction';\n\nconst waitForContracts = async () => {\n  while (true) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      return require('@fundset/contracts/localhost_deployed_contracts.json');\n    } catch {\n      console.log('Waiting for contracts to be deployed...', 'localhost_deployed_contracts.json');\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n};\n\nexport const seed = async (payload: BasePayload) => {\n  const localhostDeployments = await waitForContracts();\n\n  const fundsetSettlementLayer = await payload.findGlobal({\n    slug: 'fundset-settlement-layer',\n  });\n\n  const settlementLayerConfigs = fundsetSettlementLayer.settlementLayer ?? [];\n\n  await payload.updateGlobal({\n    slug: 'fundset-settlement-layer',\n    depth: 0,\n    data: {\n      settlementLayer: settlementLayerConfigs\n        .concat([\n          {\n            type: 'evm',\n            blockType: 'evm-settlement-layer',\n            chainConfigs: [\n              {\n                chainId: 31337,\n                rpcUrl: 'http://localhost:8545',\n                proxyAddress: localhostDeployments.DiamondProxy.address,\n                modules: [\n                  {\n                    blockType: 'evm-aa-module',\n                    bundlerUrl: '/api/bundler',\n                    paymasterUrl: 'http://localhost:4338',\n                    entryPointAddress: entryPoint07Address,\n                    providers: [\n                      {\n                        provider: 'google',\n                        mfaLevel: 'default',\n                      },\n                      {\n                        provider: 'twitter',\n                        mfaLevel: 'default',\n                      },\n                    ],\n                  },\n                  {\n                    blockType: 'evm-token-module',\n                    contracts: [{ dividendToken: localhostDeployments.ERC20.address }],\n                  },\n                ],\n              },\n            ],\n          },\n        ])\n        .toReversed(),\n    },\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/seed.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts",
      "content": "import type { Block } from 'payload';\n\nconst AaModule: Block = {\n  slug: 'evm-aa-module',\n  dbName: 'aa',\n  fields: [\n    {\n      name: 'paymasterUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'entryPointAddress',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'bundlerUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'providers',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'provider',\n          type: 'select',\n          required: true,\n          options: [\n            'google',\n            'facebook',\n            'reddit',\n            'discord',\n            'twitch',\n            'apple',\n            'line',\n            'github',\n            'kakao',\n            'linkedin',\n            'twitter',\n            'weibo',\n            'wechat',\n            'farcaster',\n            'email_passwordless',\n            'sms_passwordless',\n            'webauthn',\n            'jwt',\n            'passkeys',\n            'authenticator',\n          ].map(provider => ({\n            label: provider.charAt(0).toUpperCase() + provider.slice(1),\n            value: provider,\n          })),\n        },\n        {\n          name: 'mfaLevel',\n          type: 'select',\n          required: true,\n          options: ['default', 'optional', 'mandatory', 'none'].map(mfaLevel => ({\n            label: mfaLevel,\n            value: mfaLevel,\n          })),\n        },\n      ],\n    },\n  ],\n};\n\nconst TokenModule: Block = {\n  slug: 'evm-token-module',\n  fields: [\n    {\n      name: 'contracts',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'dividendToken',\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n  ],\n};\n\nexport const EvmSettlementLayer: Block = {\n  slug: 'evm-settlement-layer',\n  fields: [\n    {\n      name: 'chainConfigs',\n      required: true,\n      type: 'array',\n      minRows: 1,\n      dbName: 'chainConfigs',\n      fields: [\n        {\n          name: 'rpcUrl',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'chainId',\n          type: 'number',\n          required: true,\n        },\n        {\n          name: 'proxyAddress',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'modules',\n          type: 'blocks',\n          blocks: [AaModule, TokenModule],\n          required: true,\n        },\n      ],\n    },\n    {\n      name: 'type',\n      type: 'select',\n      defaultValue: 'evm',\n      required: true,\n      options: [\n        {\n          label: 'evm',\n          value: 'evm',\n        },\n      ],\n    },\n  ],\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/index.ts",
      "content": "export * from './errorCodes';\nexport * from './decodeMutationError';\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts",
      "content": "export const ERROR_CODES = {\n  TX_REJECTED_BY_USER: 'TX_REJECTED_BY_USER',\n  FAILED_TO_SWITCH_TO_REQUIRED_NETWORK: 'FAILED_TO_SWITCH_TO_REQUIRED_NETWORK',\n  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',\n  CONTRACT_EXECUTION_FAILED: 'CONTRACT_EXECUTION_FAILED',\n  CONTRACT_FUNCTION_REVERTED: 'CONTRACT_FUNCTION_REVERTED',\n  TX_REJECTED_BY_NETWORK: 'TX_REJECTED_BY_NETWORK',\n  TRANSACTION_CONFIRMATION_TIMED_OUT: 'TRANSACTION_CONFIRMATION_TIMED_OUT',\n  RPC_REQUEST_FAILED: 'RPC_REQUEST_FAILED',\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts",
      "content": "import { BaseError } from 'wagmi';\nimport {\n  UserRejectedRequestError,\n  SwitchChainError,\n  InsufficientFundsError,\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  RpcRequestError,\n  TransactionRejectedRpcError,\n  WaitForTransactionReceiptTimeoutError,\n  decodeErrorResult,\n} from 'viem';\nimport { ERROR_CODES } from '.';\nimport { UserOperationExecutionError } from 'viem/account-abstraction';\n\nimport * as AllAbis from '@fundset/contracts/abi';\n\nconst ALL_CUSTOM_SOLIDITY_ERRORS = Object.values(AllAbis)\n  .flat()\n  .filter(f => f.type === 'error');\n\n// TODO: handle all errors\nexport const decodeMutationError = (error: Error | null) => {\n  if (!error) return null;\n\n  // Handle wagmi-specific errors\n  if (error instanceof UserRejectedRequestError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_USER, { cause: error });\n  }\n\n  if (error instanceof SwitchChainError) {\n    return new Error(ERROR_CODES.FAILED_TO_SWITCH_TO_REQUIRED_NETWORK, { cause: error });\n  }\n\n  // Handle viem-specific blockchain errors\n  if (error instanceof InsufficientFundsError) {\n    return new Error(ERROR_CODES.INSUFFICIENT_FUNDS, { cause: error });\n  }\n\n  if (error instanceof UserOperationExecutionError) {\n    try {\n      // Handle custom solidity errors\n      const decoded = decodeErrorResult({\n        data: `0x${error.details.split('0x')[1]}`,\n        abi: ALL_CUSTOM_SOLIDITY_ERRORS,\n      });\n      return new Error(decoded.errorName, { cause: error });\n    } catch {\n      // ignore decode errors\n    }\n\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionExecutionError) {\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionRevertedError) {\n    return new Error(ERROR_CODES.CONTRACT_FUNCTION_REVERTED, { cause: error });\n  }\n\n  if (error instanceof TransactionRejectedRpcError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_NETWORK, { cause: error });\n  }\n\n  if (error instanceof WaitForTransactionReceiptTimeoutError) {\n    return new Error(ERROR_CODES.TRANSACTION_CONFIRMATION_TIMED_OUT, { cause: error });\n  }\n\n  if (error instanceof RpcRequestError) {\n    return new Error(ERROR_CODES.RPC_REQUEST_FAILED, { cause: error });\n  }\n\n  // Handle BaseError (wagmi base class) or generic errors\n  if (error instanceof BaseError || error instanceof Error) {\n    return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n  }\n\n  // Handle unknown errors\n  return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/index.ts",
      "content": "export { SESSION_TIME } from './base';\nexport { LOGIN_PROVIDER, type LOGIN_PROVIDER_TYPE, MFA_LEVELS } from '@web3auth/auth-adapter';\nexport * from './providers';\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/create.ts",
      "content": "import type { IProvider } from '@web3auth/base';\nimport {\n  createPublicClient,\n  getAddress,\n  http,\n  SwitchChainError,\n  UserRejectedRequestError,\n  type Chain,\n  type EIP1193Provider,\n} from 'viem';\nimport { ChainNotConfiguredError, createConnector } from 'wagmi';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WALLET_ADAPTERS } from '@web3auth/base';\nimport { toKernelSmartAccount } from 'permissionless/accounts';\nimport { createSmartAccountClient, type SmartAccountClient } from 'permissionless';\nimport { type Web3AuthConnectorParams } from '@web3auth/web3auth-wagmi-connector';\nimport { entryPoint07Address } from 'viem/account-abstraction';\nimport { createPimlicoClient } from 'permissionless/clients/pimlico';\nimport type { EvmAccountAbstractionModule } from '../../config.type';\n\ntype SmartAccountConnector = ReturnType<\n  Parameters<typeof createConnector<SmartAccountClient>>[0]\n> & {\n  getEoaProvider: () => Promise<IProvider>;\n  getSmartAccountProvider: (eoaProvider: IProvider) => Promise<SmartAccountClient>;\n};\n\nexport const createWeb3AuthConnector = (\n  parameters: Web3AuthConnectorParams & {\n    accountAbstractionConfigs: (EvmAccountAbstractionModule & { chainId: number })[];\n  },\n) => {\n  const { web3AuthInstance, loginParams, id, name, type, accountAbstractionConfigs } = parameters;\n\n  let eoaWalletProvider: IProvider | null = null;\n  let smartAccountProvider: SmartAccountClient | null = null;\n\n  return createConnector<SmartAccountClient>(config => ({\n    id: id || 'web3auth',\n    name: name || 'Web3Auth',\n    type: type || 'Web3Auth',\n    async connect({ chainId } = {}) {\n      try {\n        config.emitter.emit('message', {\n          type: 'connecting',\n        });\n\n        const provider = await (this as SmartAccountConnector).getEoaProvider();\n\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect.bind(this));\n\n        if (!web3AuthInstance.connected) {\n          if (loginParams) {\n            await web3AuthInstance.connectTo(WALLET_ADAPTERS.AUTH, loginParams);\n          } else {\n            console.error('please provide valid loginParams when using @web3auth/no-modal');\n            throw new UserRejectedRequestError(\n              'please provide valid loginParams when using @web3auth/no-modal' as unknown as Error,\n            );\n          }\n        }\n\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch(error => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        const accounts = await this.getAccounts();\n\n        return { accounts, chainId: currentChainId };\n      } catch (error) {\n        console.error('error while connecting', error);\n        this.onDisconnect();\n        throw new UserRejectedRequestError('Something went wrong' as unknown as Error);\n      }\n    },\n    async getAccounts() {\n      const scProvider = await (this as SmartAccountConnector).getSmartAccountProvider(\n        await (this as SmartAccountConnector).getEoaProvider(),\n      );\n      if (!scProvider) {\n        throw new Error('Smart Account Provider not found');\n      }\n      return [scProvider.account!.address];\n    },\n    async getChainId() {\n      const provider = await (this as SmartAccountConnector).getEoaProvider();\n      const chainId = await provider.request<unknown, number>({ method: 'eth_chainId' });\n      return Number(chainId);\n    },\n    async getProvider(): Promise<SmartAccountClient> {\n      return (this as SmartAccountConnector).getSmartAccountProvider(\n        await (this as SmartAccountConnector).getEoaProvider(),\n      );\n    },\n    async getClient() {\n      return this.getProvider();\n    },\n    async getEoaProvider() {\n      if (eoaWalletProvider) {\n        return eoaWalletProvider;\n      }\n      if (web3AuthInstance.status === ADAPTER_STATUS.NOT_READY) {\n        if (loginParams) {\n          await web3AuthInstance.init();\n        } else {\n          console.error('please provide valid loginParams when using @web3auth/no-modal');\n          throw new UserRejectedRequestError(\n            'please provide valid loginParams when using @web3auth/no-modal' as unknown as Error,\n          );\n        }\n      }\n\n      eoaWalletProvider = web3AuthInstance.provider!;\n      return eoaWalletProvider;\n    },\n    async getSmartAccountProvider(eoaProvider: IProvider) {\n      const currentChainId = await this.getChainId();\n\n      // Check if we need to recreate the provider for a different chain\n      if (smartAccountProvider && smartAccountProvider.chain?.id === currentChainId) {\n        return smartAccountProvider;\n      }\n\n      const selectedChain = config.chains.find(x => x.id === currentChainId);\n      if (!selectedChain) {\n        throw new Error(`Chain ${currentChainId} not found`);\n      }\n      const publicClient = createPublicClient({\n        chain: selectedChain,\n        transport: http(config.transports?.[currentChainId]?.({}).value?.url),\n      });\n\n      const simpleSmartAccount = await toKernelSmartAccount({\n        owners: [eoaProvider as EIP1193Provider],\n        client: publicClient,\n        entryPoint: {\n          address: entryPoint07Address,\n          version: '0.7',\n        },\n        index: 0n,\n      });\n\n      const accountAbstractionChainConfig = accountAbstractionConfigs.find(\n        x => x.chainId === currentChainId,\n      );\n\n      if (!accountAbstractionChainConfig) {\n        throw new Error(`Account abstraction module not found for chain ${currentChainId}`);\n      }\n\n      const paymasterClient = createPimlicoClient({\n        transport: http(accountAbstractionChainConfig.paymasterUrl),\n        entryPoint: {\n          address: entryPoint07Address,\n          version: '0.7',\n        },\n      });\n\n      const smartAccountClient = createSmartAccountClient({\n        bundlerTransport: http(accountAbstractionChainConfig.bundlerUrl),\n        chain: selectedChain,\n        account: simpleSmartAccount,\n        paymaster: paymasterClient,\n        userOperation: {\n          estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast,\n        },\n      });\n\n      smartAccountProvider = smartAccountClient;\n\n      return smartAccountClient;\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ chainId }): Promise<Chain> {\n      try {\n        const chain = config.chains.find(x => x.id === chainId);\n        if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n        await web3AuthInstance.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId: `0x${chain.id.toString(16)}`,\n          rpcTarget: chain.rpcUrls.default.http[0]!,\n          displayName: chain.name,\n          blockExplorerUrl: chain.blockExplorers?.default.url || '',\n          ticker: chain.nativeCurrency?.symbol || 'ETH',\n          tickerName: chain.nativeCurrency?.name || 'Ethereum',\n          decimals: chain.nativeCurrency?.decimals || 18,\n          logo: chain.nativeCurrency?.symbol\n            ? `https://images.toruswallet.io/${chain.nativeCurrency?.symbol.toLowerCase()}.svg`\n            : 'https://images.toruswallet.io/eth.svg',\n        });\n        console.info('Chain Added: ', chain.name);\n        await web3AuthInstance.switchChain({ chainId: `0x${chain.id.toString(16)}` });\n        console.info('Chain Switched to ', chain.name);\n        config.emitter.emit('change', {\n          chainId,\n        });\n        return chain;\n      } catch (error: unknown) {\n        console.error('Error: Cannot change chain', error);\n        throw new SwitchChainError(error as Error);\n      }\n    },\n    async disconnect(): Promise<void> {\n      await web3AuthInstance.logout();\n      const provider = await (this as SmartAccountConnector).getEoaProvider();\n      provider.removeListener('accountsChanged', this.onAccountsChanged);\n      provider.removeListener('chainChanged', this.onChainChanged);\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) config.emitter.emit('disconnect');\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map(x => getAddress(x)),\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    onDisconnect(): void {\n      config.emitter.emit('disconnect');\n    },\n  }));\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/create.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/base.ts",
      "content": "import { Web3AuthNoModal } from '@web3auth/no-modal';\nimport { EthereumPrivateKeyProvider } from '@web3auth/ethereum-provider';\nimport { CHAIN_NAMESPACES, WEB3AUTH_NETWORK } from '@web3auth/base';\nimport { hardhat } from 'wagmi/chains';\n\nimport {\n  AuthAdapter,\n  type LANGUAGE_TYPE,\n  type LOGIN_PROVIDER_TYPE,\n  type MfaLevelType,\n} from '@web3auth/auth-adapter';\nimport { createWeb3AuthConnector } from './create';\nimport type { EvmAccountAbstractionModule } from '../../config.type';\nimport { evmSettlementLayerEnv } from '../../env';\n\ntype Web3AuthInstanceConfig = {\n  chainId: number;\n  rpcUrl: string;\n  displayName: string;\n  blockExplorerUrl?: string;\n};\n\nexport const SESSION_TIME = 1000 * 60 * 60 * 24 * 7; // 7 days\n\nconst getWeb3AuthInstance = ({\n  chainId,\n  rpcUrl,\n  displayName,\n  blockExplorerUrl,\n}: Web3AuthInstanceConfig) => {\n  const clientId = evmSettlementLayerEnv().NEXT_PUBLIC_WEB3AUTH_CLIENT_ID;\n  if (!clientId) {\n    throw new Error('NEXT_PUBLIC_WEB3AUTH_CLIENT_ID is not set');\n  }\n\n  const chainConfig = {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    chainId: '0x' + chainId.toString(16),\n    rpcTarget: rpcUrl,\n    displayName,\n    tickerName: hardhat.nativeCurrency?.name,\n    ticker: hardhat.nativeCurrency?.symbol,\n    blockExplorerUrl: blockExplorerUrl,\n    logo: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=040',\n  };\n\n  const privateKeyProvider = new EthereumPrivateKeyProvider({ config: { chainConfig } });\n\n  const web3AuthInstance = new Web3AuthNoModal({\n    clientId,\n    chainConfig,\n    privateKeyProvider,\n    web3AuthNetwork: WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,\n  });\n\n  return web3AuthInstance;\n};\n\ntype Web3AuthNoModalConnectorConfig = {\n  whiteLabel?: {\n    logoLight: string;\n    logoDark: string;\n    defaultLanguage: LANGUAGE_TYPE;\n    appName: string;\n    theme: {\n      primary: string;\n      onPrimary: string;\n    };\n    mode: 'dark' | 'light';\n    appUrl: string;\n  };\n  loginParams?: {\n    loginProvider: LOGIN_PROVIDER_TYPE;\n    mfaLevel: MfaLevelType;\n  };\n};\n\nexport const createWeb3AuthNoModalConnector = (\n  props: Web3AuthInstanceConfig &\n    Web3AuthNoModalConnectorConfig & {\n      accountAbstractionConfigs: (EvmAccountAbstractionModule & { chainId: number })[];\n    },\n) => {\n  const web3AuthInstance = getWeb3AuthInstance(props);\n\n  const clientId = evmSettlementLayerEnv().NEXT_PUBLIC_WEB3AUTH_CLIENT_ID;\n  if (!clientId) {\n    throw new Error('NEXT_PUBLIC_WEB3AUTH_CLIENT_ID is not set');\n  }\n\n  const authAdapter = new AuthAdapter({\n    sessionTime: SESSION_TIME,\n    adapterSettings: {\n      clientId,\n      network: 'testnet',\n      uxMode: 'popup',\n      whiteLabel: props.whiteLabel ?? {\n        logoLight: 'https://codefunded.com/images/codefunded-logo-default.svg',\n        logoDark: 'https://codefunded.com/images/codefunded-logo-dark.svg',\n        defaultLanguage: 'en',\n        appName: 'CodeFunded',\n        theme: {\n          primary: '#FF4A14',\n          onPrimary: '#1C1E1D',\n        },\n        mode: 'dark',\n        appUrl: 'https://codefunded.com',\n      },\n    },\n  });\n  web3AuthInstance.configureAdapter(authAdapter);\n\n  const connector = createWeb3AuthConnector({\n    web3AuthInstance,\n    id: `web3auth-${props.loginParams?.loginProvider}`,\n    name: `Web3Auth ${props.loginParams?.loginProvider}`,\n    loginParams: {\n      loginProvider: props.loginParams?.loginProvider ?? 'google',\n      curve: 'secp256k1',\n      mfaLevel: props.loginParams?.mfaLevel ?? 'none',\n    },\n    accountAbstractionConfigs: props.accountAbstractionConfigs,\n  });\n\n  return connector;\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/base.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/providers/index.ts",
      "content": "import type { Config } from 'wagmi';\n\nimport type { LOGIN_PROVIDER_TYPE } from '@web3auth/auth-adapter';\nimport { createWeb3AuthNoModalConnector } from '../base';\nimport type { EvmSettlementLayerConfig } from '../../../config.type';\n\nexport const getWeb3AuthConnector = ({\n  wagmiConfig,\n  chainConfigs,\n  selectedChainId,\n  provider,\n}: {\n  wagmiConfig: Config;\n  chainConfigs: EvmSettlementLayerConfig['chainConfigs'];\n  selectedChainId: number;\n  provider: LOGIN_PROVIDER_TYPE;\n}) => {\n  const selectedChain = wagmiConfig.chains.find(chain => chain.id === selectedChainId);\n  if (!selectedChain) {\n    throw new Error(`Chain ${selectedChainId} not found`);\n  }\n\n  const accountAbstractionConfigs = chainConfigs\n    .map(chainConfig => ({\n      chainId: chainConfig.chainId,\n      aaModule: chainConfig.modules.find(module => module.blockType === 'evm-aa-module'),\n    }))\n    .filter(aaConfig => aaConfig.aaModule)\n    .map(aaConfig => ({\n      chainId: aaConfig.chainId,\n      paymasterUrl: aaConfig.aaModule!.paymasterUrl,\n      entryPointAddress: aaConfig.aaModule!.entryPointAddress,\n      bundlerUrl: aaConfig.aaModule!.bundlerUrl,\n      providers: aaConfig.aaModule!.providers,\n      blockType: 'evm-aa-module' as const,\n    }));\n\n  const chainConfig = chainConfigs.find(chainConfig => chainConfig.chainId === selectedChainId);\n\n  const accountAbstractionChainConfig = chainConfig?.modules.find(\n    module => module.blockType === 'evm-aa-module',\n  );\n  if (!accountAbstractionChainConfig) {\n    throw new Error(`Account abstraction module not found for chain ${selectedChainId}`);\n  }\n\n  const providerConfig = accountAbstractionChainConfig.providers.find(p => p.provider === provider);\n  if (!providerConfig) {\n    throw new Error(`Provider ${provider} not found`);\n  }\n\n  return createWeb3AuthNoModalConnector({\n    chainId: selectedChainId,\n    rpcUrl:\n      wagmiConfig._internal.transports?.[selectedChainId]?.({}).value?.url ||\n      selectedChain.rpcUrls.default.http[0],\n    displayName: selectedChain.name,\n    loginParams: { loginProvider: provider, mfaLevel: providerConfig.mfaLevel },\n    accountAbstractionConfigs,\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/providers/index.ts"
    },
    {
      "path": "../web/src/features/auth/evm/index.tsx",
      "content": "'use client';\n\nimport { Button } from '@/components/ui/button';\nimport { useConnect, useDisconnect, useAccount, useBalance, useConfig, useChainId } from 'wagmi';\nimport { getWeb3AuthConnector } from '@/_fundset/settlement-layer/evm';\nimport { useReconnectWeb3Auth } from './useReconnectWeb3Auth';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { useTranslations } from 'next-intl';\nimport { withClientOnly } from '@/components/utils/client-only';\nimport { useEvmChainConfigs } from '@/_fundset/settlement-layer/evm';\n\nconst EvmAuthComponentSkeleton = () => (\n  <div className=\"flex flex-col items-center gap-2\">\n    <Skeleton className=\"h-6 w-[300px]\" />\n    <Skeleton className=\"h-9 w-[100px]\" />\n    <Skeleton className=\"h-6 w-[100px]\" />\n  </div>\n);\n\nconst EvmAuthComponent = withClientOnly(\n  () => {\n    const { connectors, connect } = useConnect();\n    const { disconnect } = useDisconnect();\n    const { status, address, connector } = useAccount();\n    const config = useConfig();\n    const chainId = useChainId();\n    const { data: balance } = useBalance({\n      address,\n      query: {\n        refetchInterval: 5000,\n      },\n    });\n    const t = useTranslations('HomePage');\n\n    const chainConfigs = useEvmChainConfigs();\n\n    useReconnectWeb3Auth();\n\n    if (status === 'connected') {\n      return (\n        <div className=\"flex flex-col items-center justify-center gap-2\">\n          <div>{t('connected_with', { address, connector: connector.name })}</div>\n          <Button variant=\"destructive\" onClick={() => disconnect()}>\n            {t('disconnect')}\n          </Button>\n          <div>Balance: {balance?.value}</div>\n        </div>\n      );\n    }\n\n    if (status === 'connecting' || status === 'reconnecting') {\n      return <EvmAuthComponentSkeleton />;\n    }\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {chainConfigs\n          .find(chainConfig => chainConfig.chainId === chainId)\n          ?.modules.find(module => module.blockType === 'evm-aa-module')\n          ?.providers.map(({ provider }) => (\n            <Button\n              key={provider}\n              onClick={() =>\n                connect({\n                  connector: getWeb3AuthConnector({\n                    wagmiConfig: config,\n                    chainConfigs,\n                    selectedChainId: chainId,\n                    provider,\n                  }),\n                })\n              }\n            >\n              {t('login_with', { connector: provider.charAt(0).toUpperCase() + provider.slice(1) })}\n            </Button>\n          ))}\n        {connectors.map(connector => (\n          <Button key={connector.id} onClick={() => connect({ connector })}>\n            {t('login_with', { connector: connector.name })}\n          </Button>\n        ))}\n      </div>\n    );\n  },\n  () => <EvmAuthComponentSkeleton />,\n);\n\nexport default EvmAuthComponent;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/index.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/useReconnectWeb3Auth.ts",
      "content": "'use client';\n\nimport { useEvmChainConfigs } from '@/_fundset/settlement-layer/evm';\nimport {\n  getWeb3AuthConnector,\n  LOGIN_PROVIDER_TYPE,\n  SESSION_TIME,\n} from '@/_fundset/settlement-layer/evm';\nimport { useLocalStorage } from '@uidotdev/usehooks';\nimport { useEffect, useLayoutEffect } from 'react';\nimport { useAccountEffect, useChainId, useConfig, useConnect } from 'wagmi';\n\nconst useConnections = () => {\n  const CURRENT_VERSION = 1;\n  const [connections, setConnections] = useLocalStorage('fundset.connections', {\n    state: { chainId: 0, current: null, connections: { value: [] } },\n    version: CURRENT_VERSION,\n  } as {\n    version: number;\n    state: {\n      chainId: number;\n      current: string | null;\n      connections: {\n        value: [\n          string,\n          {\n            accounts: string[];\n            chainId: number;\n            connector: {\n              id: string;\n              name: string;\n              type: string;\n              uid: string;\n            };\n            sessionFinishAt: number;\n          },\n        ][];\n      };\n    };\n  });\n\n  useEffect(\n    function migrateConnectionsToLatestVersionIfNeeded() {\n      if (connections.version !== CURRENT_VERSION) {\n        setConnections({\n          version: CURRENT_VERSION,\n          state: { chainId: 0, current: null, connections: { value: [] } },\n        });\n      }\n    },\n    [connections.version, setConnections],\n  );\n\n  useEffect(\n    function clearConnectionsIfSessionIsExpired() {\n      if (!connections.state.current) {\n        return;\n      }\n      const connection = connections.state.connections.value.find(\n        ([uid]) => uid === connections.state.current,\n      );\n      if (!connection) {\n        return;\n      }\n      if (connection[1].sessionFinishAt < Date.now()) {\n        setConnections(prev => ({\n          ...prev,\n          state: { ...prev.state, current: null, connections: { value: [] } },\n        }));\n      }\n    },\n    [connections.state, setConnections],\n  );\n\n  useAccountEffect({\n    onConnect: account => {\n      setConnections(prev => ({\n        ...prev,\n        state: {\n          ...prev.state,\n          current: account.connector.uid,\n          connections: {\n            value: [\n              [\n                account.connector.uid,\n                {\n                  accounts: [account.address],\n                  chainId: account.chainId,\n                  connector: {\n                    id: account.connector.id,\n                    name: account.connector.name,\n                    type: account.connector.type,\n                    uid: account.connector.uid,\n                  },\n                  sessionFinishAt: Date.now() + SESSION_TIME,\n                },\n              ],\n            ],\n          },\n        },\n      }));\n    },\n    onDisconnect: () => {\n      setConnections(prev => ({\n        ...prev,\n        state: {\n          ...prev.state,\n          current: null,\n          connections: {\n            value: [],\n          },\n        },\n      }));\n    },\n  });\n\n  return connections;\n};\n\nexport const useReconnectWeb3Auth = () => {\n  const connections = useConnections();\n  const { connect } = useConnect();\n  const config = useConfig();\n  const chainId = useChainId();\n  const chainConfigs = useEvmChainConfigs();\n\n  useLayoutEffect(\n    function reconnectWeb3AuthIfIsLoggedIn() {\n      if (!connections.state.current) return;\n      const connector = connections.state.connections.value.at(0)?.[1];\n      if (!connector || connector.connector.type !== 'Web3Auth') return;\n      if (connector.sessionFinishAt < Date.now()) return;\n\n      const lastProvider = connector.connector.id.split('-')[1] as LOGIN_PROVIDER_TYPE;\n\n      connect({\n        connector: getWeb3AuthConnector({\n          wagmiConfig: config,\n          chainConfigs,\n          selectedChainId: chainId,\n          provider: lastProvider,\n        }),\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/useReconnectWeb3Auth.ts"
    },
    {
      "path": "../evm/indexer/src/EventHandlers.ts",
      "content": "/*\n * Please refer to https://docs.envio.dev for a thorough guide on all Envio indexer features\n */\n\nimport {\n  DiamondProxy,\n  DiamondProxy_DiamondCut,\n  DiamondProxy_OwnershipTransferred,\n} from 'generated';\nimport './modules';\n\nDiamondProxy.DiamondCut.handler(async ({ event, context }) => {\n  for (const facetCut of event.params._0) {\n    const [facetAddress, action, functionSelectors] = facetCut;\n    const entity: DiamondProxy_DiamondCut = {\n      id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n      diamondAction: action,\n      init: event.params._1,\n      calldata: event.params._2,\n      facetAddress: facetAddress.toString(),\n      functionSelectors: functionSelectors.map(selector => selector.toString()),\n    };\n    context.DiamondProxy_DiamondCut.set(entity);\n  }\n});\n\nDiamondProxy.OwnershipTransferred.handler(async ({ event, context }) => {\n  const entity: DiamondProxy_OwnershipTransferred = {\n    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n    newOwner: event.params._0,\n    previousOwner: event.params._1,\n  };\n  context.DiamondProxy_OwnershipTransferred.set(entity);\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/indexer/src/EventHandlers.ts"
    }
  ],
  "meta": {
    "dependencies": {
      "web": [
        "zod",
        "@t3-oss/env-nextjs",
        "wagmi",
        "viem",
        "@web3auth/auth-adapter",
        "@web3auth/base",
        "@web3auth/no-modal",
        "@web3auth/ethereum-provider",
        "permissionless",
        "@web3auth/web3auth-wagmi-connector",
        "@uidotdev/usehooks"
      ]
    }
  }
}
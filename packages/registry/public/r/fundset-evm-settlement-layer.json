{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fundset-evm-settlement-layer",
  "type": "registry:item",
  "title": "fundset-evm-settlement-layer",
  "description": "fundset-evm-settlement-layer",
  "registryDependencies": [
    "https://fundset.vercel.app/r/fundset-core.json"
  ],
  "files": [
    {
      "path": "../evm/contracts/contracts/DiamondProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { SolidStateDiamond } from '@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol';\n\ncontract DiamondProxy is SolidStateDiamond {}\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/contracts/DiamondProxy.sol"
    },
    {
      "path": "../evm/contracts/ignition/modules/DiamondProxy.ts",
      "content": "import { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\nexport const DiamondProxyModule = buildModule('DiamondProxyModule', m => {\n  const diamondProxy = m.contract('DiamondProxy');\n\n  return { diamondProxy };\n});\n\nexport default DiamondProxyModule;\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/ignition/modules/DiamondProxy.ts"
    },
    {
      "path": "../evm/contracts/test/DiamondProxy.ts",
      "content": "import { describe, it } from 'node:test';\nimport { network } from 'hardhat';\n// We don't have Ethereum specific assertions in Hardhat 3 yet\nimport assert from 'node:assert/strict';\nimport DiamondProxyModule from '../ignition/modules/DiamondProxy.ts';\nimport { toFunctionSelector, WriteContractErrorType, zeroAddress } from 'viem';\nimport CounterVersionsModule from '../ignition/modules/CounterVersions.ts';\nimport { DIAMOND_ACTIONS } from '../types/diamond-action.ts';\n\ndescribe('DiamondProxy', async function () {\n  const { viem, ignition } = await network.connect();\n\n  it('should allow to increment the counter with V1 and V2 after attaching them to the diamond proxy', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV1, counterV2 } = await ignition.deploy(CounterVersionsModule);\n\n    const selectorsV1 = counterV1.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    // attach Counter V1\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV1.address, selectors: selectorsV1 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV1 = await viem.getContractAt('CounterV1', diamondProxy.address);\n    assert.equal(await diamondWithCounterV1.read.x(), 0n);\n    await diamondWithCounterV1.write.inc();\n    assert.equal(await diamondWithCounterV1.read.x(), 1n);\n\n    // Try running V2 before attaching, should fail\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await assert.rejects(diamondWithCounterV2.write.incBy([10n]), (err: WriteContractErrorType) =>\n      err.message.includes('Proxy__ImplementationIsNotContract()'),\n    );\n\n    // attach Counter V2\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    // should work now\n    await diamondWithCounterV2.write.incBy([10n]);\n    assert.equal(await diamondWithCounterV1.read.x(), 11n);\n  });\n\n  it('should allow to increment the counter per address', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV2 } = await ignition.deploy(CounterVersionsModule);\n    const [walletClient] = await viem.getWalletClients();\n\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await diamondWithCounterV2.write.incByAddress([10n]);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([walletClient.account.address]), 10n);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([zeroAddress]), 0n);\n  });\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/test/DiamondProxy.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/index.tsx",
      "content": "'use client';\n\nimport { useEffect, useMemo } from 'react';\nimport type { EvmSettlementLayerConfig } from './config.type';\n\nimport { createContext, useContext } from 'react';\nimport { SimpleKitProvider } from '@/features/auth/evm/components/simplekit';\n\nimport { buildEvmSettlementLayer } from './buildSettlementLayer';\nimport { WagmiProvider } from './connectors/WagmiProviderWithAA';\nimport { Web3AuthProvider } from '@web3auth/modal/react';\nimport { Web3AuthOptions } from '@web3auth/modal';\nimport { evmSettlementLayerEnv } from './env';\nimport { ensureDefined } from '@/lib/ensureDefined';\n\nconst evmEnv = evmSettlementLayerEnv();\nconst web3AuthOptions = {\n  clientId: evmEnv.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID || '',\n  web3AuthNetwork: evmEnv.NEXT_PUBLIC_WEB3AUTH_NETWORK,\n} satisfies Web3AuthOptions;\n\nconst Web3AuthProviderWrapper = ({ children }: React.PropsWithChildren) => {\n  if (!evmEnv.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID) {\n    return children;\n  }\n  return <Web3AuthProvider config={{ web3AuthOptions }}>{children}</Web3AuthProvider>;\n};\n\nexport * from './config.type';\n\nexport const EvmChainConfigsContext = createContext<\n  EvmSettlementLayerConfig['chainConfigs'] | null\n>(null);\n\nexport const useEvmChainConfigs = () => {\n  const config = useContext(EvmChainConfigsContext);\n  if (!config) {\n    throw new Error('EvmChainConfigsContext not found');\n  }\n  return config;\n};\n\nexport const EvmChainConfigsProvider = ({\n  children,\n  config,\n}: React.PropsWithChildren<{\n  config: EvmSettlementLayerConfig['chainConfigs'];\n}>) => {\n  return (\n    <EvmChainConfigsContext.Provider value={config}>{children}</EvmChainConfigsContext.Provider>\n  );\n};\n\nconst EvmSettlementLayerProvider = ({\n  children,\n  ...props\n}: React.PropsWithChildren<{ config: EvmSettlementLayerConfig }>) => {\n  const { wagmiConfig } = useMemo(() => buildEvmSettlementLayer(props.config), [props.config]);\n\n  const accountAbstractionChainConfigs = useMemo(\n    () =>\n      ensureDefined(\n        props.config.chainConfigs\n          .map(chainConfig => {\n            const aaModule = chainConfig.modules.find(\n              module => module.blockType === 'evm-aa-module',\n            );\n            if (!aaModule) {\n              return null;\n            }\n            return {\n              chainId: chainConfig.chainId,\n              bundlerUrl: aaModule.bundlerUrl,\n              paymasterUrl: aaModule.paymasterUrl,\n            };\n          })\n          .filter(Boolean),\n      ),\n    [props.config.chainConfigs],\n  );\n\n  useEffect(function hotContractReload() {\n    if (process.env.NODE_ENV === 'development') {\n      const wss = new WebSocket('http://localhost:9999');\n      wss.onopen = () => {\n        console.log('Hot Contract Reload: WebSocket connection established');\n      };\n      wss.onmessage = event => {\n        if (event.data === 'reload') {\n          window.location.reload();\n        }\n      };\n      return () => {\n        console.log('Hot Contract Reload: WebSocket connection closed');\n        wss.close();\n      };\n    }\n  }, []);\n\n  return (\n    <EvmChainConfigsProvider config={props.config.chainConfigs}>\n      <Web3AuthProviderWrapper>\n        <WagmiProvider\n          config={wagmiConfig}\n          accountAbstractionChainConfigs={accountAbstractionChainConfigs}\n        >\n          <SimpleKitProvider>{children}</SimpleKitProvider>\n        </WagmiProvider>\n      </Web3AuthProviderWrapper>\n    </EvmChainConfigsProvider>\n  );\n};\n\nexport default EvmSettlementLayerProvider;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/index.tsx"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts",
      "content": "'use client';\n\nimport { useChainId, useWalletClient } from 'wagmi';\nimport { useMemo } from 'react';\nimport { useEvmChainConfigs } from '.';\nimport { buildEvmSettlementLayer } from './buildSettlementLayer';\n\nexport const useEvmSettlementLayer = () => {\n  const evmChainConfigs = useEvmChainConfigs();\n  const { data: walletClient } = useWalletClient();\n  const chainId = useChainId();\n\n  const evmSettlementLayer = useMemo(\n    () =>\n      buildEvmSettlementLayer(\n        {\n          blockType: 'evm-settlement-layer',\n          chainConfigs: evmChainConfigs,\n          type: 'evm',\n        },\n        {\n          selectedChainId: chainId,\n          walletClient,\n        },\n      ).evmSettlementLayer,\n    [evmChainConfigs, chainId, walletClient],\n  );\n\n  return evmSettlementLayer;\n};\n\nexport default useEvmSettlementLayer;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/buildSettlementLayer.ts",
      "content": "import { EvmSettlementLayerConfig } from './config.type';\nimport * as viem from 'viem';\nimport * as chains from 'wagmi/chains';\nimport { createConfig } from 'wagmi';\nimport { walletConnect } from 'wagmi/connectors';\nimport { evmSettlementLayerEnv } from './env';\nimport { EvmChainModules, EvmModule } from './config.type';\n\nimport { buildCounterModule } from '../modules/counter/evm/build';\n\nexport const buildEvmSettlementLayer = (\n  config: EvmSettlementLayerConfig,\n  {\n    walletClient,\n    selectedChainId,\n  }: {\n    walletClient?: viem.WalletClient<viem.Transport, viem.Chain, viem.Account>;\n    selectedChainId?: number;\n  } = {},\n) => {\n  const chainConfigs = config.chainConfigs.map(chain =>\n    Object.values(chains).find(c => c.id === chain.chainId),\n  );\n\n  if (chainConfigs.length === 0) {\n    throw new Error(`Chains [${config.chainConfigs.map(c => c.chainId).join(', ')}] not found`);\n  }\n\n  const transports = config.chainConfigs.reduce(\n    (acc, chain) => ({\n      ...acc,\n      [chain.chainId]: viem.http(chain.rpcUrl, {\n        retryCount: 5,\n        retryDelay: 200,\n        batch: { wait: 100 },\n      }),\n    }),\n    {} as Record<number, viem.HttpTransport<undefined, false>>,\n  );\n\n  const wagmiConfig = createConfig({\n    chains: chainConfigs as unknown as readonly [viem.Chain, ...viem.Chain[]],\n    transports,\n    ssr: true,\n    multiInjectedProviderDiscovery: true,\n    connectors:\n      typeof window !== 'undefined'\n        ? [\n            walletConnect({\n              projectId: evmSettlementLayerEnv().NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID || '',\n            }),\n          ]\n        : [],\n  });\n\n  const evmModules = config.chainConfigs.reduce((acc, chainConfig) => {\n    acc[chainConfig.chainId] = {\n      proxyAddress: chainConfig.proxyAddress,\n      contracts: chainConfig.modules.reduce(\n        (contractsAcc, module) => {\n          if ('contracts' in module) {\n            module.contracts.forEach(contract => {\n              Object.entries(contract).forEach(([key, value]) => {\n                if (key === 'id' || value === null) {\n                  return;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (contractsAcc as any)[key] = value as `0x${string}`;\n              });\n            });\n          }\n          return contractsAcc;\n        },\n        {} as EvmModule['contracts'],\n      ),\n    };\n    return acc;\n  }, {} as EvmChainModules);\n\n  const chainId = selectedChainId ?? config.chainConfigs[0].chainId;\n\n  const chain = Object.values(chains).find(c => c.id === chainId) as chains.Chain;\n\n  const evmModule = evmModules[chainId];\n  if (!evmModule) {\n    throw new Error(`Evm module not found for chainId: ${chainId}`);\n  }\n\n  const evmSettlementLayer = {\n    name: 'evm',\n    ...buildCounterModule({\n      evmModule,\n      chain,\n      walletClient,\n      config: wagmiConfig,\n    }),\n  };\n\n  return {\n    evmSettlementLayer,\n    evmModules,\n    chainId,\n    chain,\n    wagmiConfig,\n    transports,\n  };\n};\n\nexport default buildEvmSettlementLayer;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/buildSettlementLayer.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/serverSideSettlementLayer.tsx",
      "content": "'use server';\n\nimport { dehydrate, HydrationBoundary, QueryClient } from '@tanstack/react-query';\nimport { EvmSettlementLayerConfig } from './config.type';\nimport { buildEvmSettlementLayer } from './buildSettlementLayer';\n\nexport default async function EvmSettlementLayerServerSide({\n  children,\n  config,\n}: React.PropsWithChildren<{ config: EvmSettlementLayerConfig }>) {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 5_000,\n      },\n    },\n  });\n\n  const { evmSettlementLayer } = buildEvmSettlementLayer(config);\n\n  await queryClient.prefetchQuery(evmSettlementLayer.counter.globalCounterValueQueryOptions());\n\n  return <HydrationBoundary state={dehydrate(queryClient)}>{children}</HydrationBoundary>;\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/serverSideSettlementLayer.tsx"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/env.ts",
      "content": "import { createEnv } from '@t3-oss/env-nextjs';\nimport { WEB3AUTH_NETWORK } from '@web3auth/modal';\nimport { z } from 'zod';\n\nexport const evmSettlementLayerEnv = () =>\n  createEnv({\n    client: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: z.string().optional(),\n      NEXT_PUBLIC_WEB3AUTH_NETWORK: z\n        .custom<(typeof WEB3AUTH_NETWORK)[keyof typeof WEB3AUTH_NETWORK]>()\n        .optional()\n        .default(WEB3AUTH_NETWORK.SAPPHIRE_DEVNET),\n      NEXT_PUBLIC_INDEXER_URL: z.string().default('http://localhost:8080/v1/graphql'),\n      NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID: z.string().optional(),\n    },\n    experimental__runtimeEnv: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: process.env.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID,\n      NEXT_PUBLIC_WEB3AUTH_NETWORK: process.env.NEXT_PUBLIC_WEB3AUTH_NETWORK,\n      NEXT_PUBLIC_INDEXER_URL: process.env.NEXT_PUBLIC_INDEXER_URL,\n      NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID: process.env.NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID,\n    },\n    emptyStringAsUndefined: true,\n  });\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/env.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/config.type.ts",
      "content": "import { FundsetSettlementLayer } from '@/payload-types';\n\nexport type EvmSettlementLayerConfig = Extract<\n  NonNullable<FundsetSettlementLayer['settlementLayer']>[number],\n  { type: 'evm' }\n>;\n\nexport type EvmModule = {\n  proxyAddress: string;\n  contracts: EvmContracts;\n};\n\nexport type EvmChainModules = Record<number, EvmModule>;\n\ntype ModulesWithContracts = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { contracts: object }\n>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\nexport type EvmContracts = UnionToIntersection<\n  ModulesWithContracts extends infer M\n    ? M extends { contracts: infer C }\n      ? C extends Array<infer T>\n        ? Omit<T, 'id'>\n        : never\n      : never\n    : never\n>;\n\nexport type EvmAccountAbstractionModule = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { blockType: 'evm-aa-module' }\n>;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/config.type.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/helpers.ts",
      "content": "import { evmSettlementLayerEnv } from './env';\nimport { graphql } from 'gql.tada';\nimport { request } from 'graphql-request';\n\nconst env = evmSettlementLayerEnv();\n\nexport const isTransactionIndexed = async (hash: string) => {\n  const isTransactionIndexedQuery = graphql(`\n    query IsTransactionIndexed($hash: String!) {\n      raw_events(where: { transaction_fields: { _cast: { String: { _iregex: $hash } } } }) {\n        transaction_fields\n        serial\n      }\n    }\n  `);\n  const isTransactionIndexedResult = await request(\n    env.NEXT_PUBLIC_INDEXER_URL,\n    isTransactionIndexedQuery,\n    {\n      hash,\n    },\n  );\n  return isTransactionIndexedResult.raw_events.length > 0;\n};\n\n/**\n * Check if a transaction is indexed by the indexer. It tries to fetch the transaction 8 times with a 1 second delay, if not found during this time, it returns false.\n * @param hash transaction hash to check\n */\nexport const waitForTransactionToBeIndexed = async (hash: string) => {\n  for (let i = 0; i < 8; i++) {\n    try {\n      const isTransactionIndexedResult = await isTransactionIndexed(hash);\n      if (!isTransactionIndexedResult) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        continue;\n      }\n      return true;\n    } catch (error) {\n      console.error('Transaction not indexed', error);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n  return false;\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/helpers.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/index.ts",
      "content": "import type { Config, PayloadRequest } from 'payload';\nimport { EvmSettlementLayer } from './blocks/EvmSettlementLayer';\nimport { seed } from './seed';\n\nexport const evmSettlementLayerPlugin =\n  () =>\n  (config: Config): Config => {\n    config.globals ??= [];\n\n    const fundsetSettlementLayer = config.globals.find(g => g.slug === 'fundset-settlement-layer');\n\n    if (!fundsetSettlementLayer) {\n      throw new Error(\n        'fundsetSettlementLayer not found, run fundsetBasePlugin before postgresSettlementLayerPlugin',\n      );\n    }\n\n    const settlementLayerTypeField = fundsetSettlementLayer.fields.find(\n      f => f.type === 'blocks' && f.name === 'settlementLayer',\n    )!;\n\n    if (settlementLayerTypeField.type === 'blocks') {\n      settlementLayerTypeField.blocks.push(EvmSettlementLayer);\n    }\n\n    config.endpoints ??= [];\n\n    if (process.env.NODE_ENV === 'development') {\n      config.endpoints.push({\n        path: '/evm/hot-contract-reload',\n        method: 'post',\n        handler: async (req: PayloadRequest) => {\n          const deployedContracts = await req.json?.();\n          await seed(req.payload, deployedContracts, true);\n          return new Response(JSON.stringify({ message: 'OK' }));\n        },\n      });\n    }\n\n    const defaultOnInit = config.onInit;\n\n    config.onInit = async payload => {\n      await defaultOnInit?.(payload);\n\n      const { evmSettlementLayerEnv } = await import('../env');\n      evmSettlementLayerEnv();\n\n      if (process.env.NODE_ENV === 'development') {\n        await seed(payload);\n      }\n    };\n\n    return config;\n  };\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/seed.ts",
      "content": "import { BasePayload } from 'payload';\nimport { entryPoint07Address } from 'viem/account-abstraction';\nimport type { deploy } from '@fundset/contracts/deploy';\nimport type { FundsetSettlementLayer } from '@/payload-types';\n\nconst waitForContracts = async () => {\n  while (true) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      return require('@fundset/contracts/localhost_deployed_contracts.json') as Awaited<\n        ReturnType<typeof deploy>\n      >;\n    } catch {\n      console.log('Waiting for contracts to be deployed...', 'localhost_deployed_contracts.json');\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n};\n\nexport const seed = async (\n  payload: BasePayload,\n  deployedContracts?: Awaited<ReturnType<typeof deploy>>,\n  replaceExisting = false,\n) => {\n  const localhostDeployments = deployedContracts ?? (await waitForContracts());\n\n  const fundsetSettlementLayer = await payload.findGlobal({\n    slug: 'fundset-settlement-layer',\n  });\n\n  const settlementLayerConfigs = fundsetSettlementLayer.settlementLayer ?? [];\n\n  const evmConfig: FundsetSettlementLayer['settlementLayer'] = [\n    {\n      type: 'evm',\n      blockType: 'evm-settlement-layer',\n      chainConfigs: [\n        {\n          chainId: 31337,\n          rpcUrl: 'http://localhost:8545',\n          proxyAddress: localhostDeployments.DiamondProxy.contract,\n          modules: [\n            {\n              blockType: 'evm-aa-module',\n              bundlerUrl: '/api/bundler',\n              paymasterUrl: 'http://localhost:4338',\n              entryPointAddress: entryPoint07Address,\n              providers: [\n                {\n                  provider: 'google',\n                  mfaLevel: 'default',\n                },\n                {\n                  provider: 'twitter',\n                  mfaLevel: 'default',\n                },\n              ],\n            },\n            {\n              blockType: 'evm-token-module',\n              contracts: [{ token: localhostDeployments.ERC20.contract }],\n            },\n          ],\n        },\n      ],\n    },\n  ];\n\n  let newConfigs;\n  if (replaceExisting) {\n    // Remove all existing evm configs, then add ours\n    const filtered = settlementLayerConfigs.filter(c => c.type !== 'evm');\n    newConfigs = [...filtered, ...evmConfig];\n  } else {\n    // Only add if not present\n    const hasEvm = settlementLayerConfigs.some(c => c?.type === 'evm');\n    newConfigs = hasEvm ? settlementLayerConfigs : [...settlementLayerConfigs, ...evmConfig];\n  }\n\n  await payload.updateGlobal({\n    slug: 'fundset-settlement-layer',\n    data: {\n      settlementLayer: newConfigs.toReversed(),\n    },\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/seed.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts",
      "content": "import type { Block } from 'payload';\n\nconst AaModule: Block = {\n  slug: 'evm-aa-module',\n  dbName: 'aa',\n  fields: [\n    {\n      name: 'paymasterUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'entryPointAddress',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'bundlerUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'providers',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'provider',\n          type: 'select',\n          required: true,\n          options: [\n            'google',\n            'facebook',\n            'reddit',\n            'discord',\n            'twitch',\n            'apple',\n            'line',\n            'github',\n            'kakao',\n            'linkedin',\n            'twitter',\n            'weibo',\n            'wechat',\n            'farcaster',\n            'email_passwordless',\n            'sms_passwordless',\n            'webauthn',\n            'jwt',\n            'passkeys',\n            'authenticator',\n          ].map(provider => ({\n            label: provider.charAt(0).toUpperCase() + provider.slice(1),\n            value: provider,\n          })),\n        },\n        {\n          name: 'mfaLevel',\n          type: 'select',\n          required: true,\n          options: ['default', 'optional', 'mandatory', 'none'].map(mfaLevel => ({\n            label: mfaLevel,\n            value: mfaLevel,\n          })),\n        },\n      ],\n    },\n  ],\n};\n\nconst TokenModule: Block = {\n  slug: 'evm-token-module',\n  fields: [\n    {\n      name: 'contracts',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'token',\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n  ],\n};\n\nexport const EvmSettlementLayer: Block = {\n  slug: 'evm-settlement-layer',\n  fields: [\n    {\n      name: 'chainConfigs',\n      required: true,\n      type: 'array',\n      minRows: 1,\n      dbName: 'chainConfigs',\n      fields: [\n        {\n          name: 'rpcUrl',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'chainId',\n          type: 'number',\n          required: true,\n        },\n        {\n          name: 'proxyAddress',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'modules',\n          type: 'blocks',\n          blocks: [AaModule, TokenModule],\n          required: true,\n        },\n      ],\n    },\n    {\n      name: 'type',\n      type: 'select',\n      defaultValue: 'evm',\n      required: true,\n      options: [\n        {\n          label: 'evm',\n          value: 'evm',\n        },\n      ],\n    },\n  ],\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/index.ts",
      "content": "export * from './errorCodes';\nexport * from './decodeMutationError';\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts",
      "content": "export const ERROR_CODES = {\n  TX_REJECTED_BY_USER: 'TX_REJECTED_BY_USER',\n  FAILED_TO_SWITCH_TO_REQUIRED_NETWORK: 'FAILED_TO_SWITCH_TO_REQUIRED_NETWORK',\n  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',\n  CONTRACT_EXECUTION_FAILED: 'CONTRACT_EXECUTION_FAILED',\n  CONTRACT_FUNCTION_REVERTED: 'CONTRACT_FUNCTION_REVERTED',\n  TX_REJECTED_BY_NETWORK: 'TX_REJECTED_BY_NETWORK',\n  TRANSACTION_CONFIRMATION_TIMED_OUT: 'TRANSACTION_CONFIRMATION_TIMED_OUT',\n  RPC_REQUEST_FAILED: 'RPC_REQUEST_FAILED',\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts",
      "content": "import { BaseError } from 'wagmi';\nimport {\n  UserRejectedRequestError,\n  SwitchChainError,\n  InsufficientFundsError,\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  RpcRequestError,\n  TransactionRejectedRpcError,\n  WaitForTransactionReceiptTimeoutError,\n  decodeErrorResult,\n} from 'viem';\nimport { ERROR_CODES } from '.';\nimport { UserOperationExecutionError } from 'viem/account-abstraction';\n\nimport * as AllAbis from '@fundset/contracts/abi';\n\nconst ALL_CUSTOM_SOLIDITY_ERRORS = Object.values(AllAbis)\n  .flat()\n  .filter(f => f.type === 'error');\n\n// TODO: handle all errors\nexport const decodeMutationError = (error: Error | null) => {\n  if (!error) return null;\n\n  // Handle wagmi-specific errors\n  if (error instanceof UserRejectedRequestError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_USER, { cause: error });\n  }\n\n  if (error instanceof SwitchChainError) {\n    return new Error(ERROR_CODES.FAILED_TO_SWITCH_TO_REQUIRED_NETWORK, { cause: error });\n  }\n\n  // Handle viem-specific blockchain errors\n  if (error instanceof InsufficientFundsError) {\n    return new Error(ERROR_CODES.INSUFFICIENT_FUNDS, { cause: error });\n  }\n\n  if (error instanceof UserOperationExecutionError) {\n    try {\n      // Handle custom solidity errors\n      const decoded = decodeErrorResult({\n        data: `0x${error.details.split('0x')[1]}`,\n        abi: ALL_CUSTOM_SOLIDITY_ERRORS,\n      });\n      return new Error(decoded.errorName, { cause: error });\n    } catch {\n      // ignore decode errors\n    }\n\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionExecutionError) {\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionRevertedError) {\n    return new Error(ERROR_CODES.CONTRACT_FUNCTION_REVERTED, { cause: error });\n  }\n\n  if (error instanceof TransactionRejectedRpcError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_NETWORK, { cause: error });\n  }\n\n  if (error instanceof WaitForTransactionReceiptTimeoutError) {\n    return new Error(ERROR_CODES.TRANSACTION_CONFIRMATION_TIMED_OUT, { cause: error });\n  }\n\n  if (error instanceof RpcRequestError) {\n    return new Error(ERROR_CODES.RPC_REQUEST_FAILED, { cause: error });\n  }\n\n  // Handle BaseError (wagmi base class) or generic errors\n  if (error instanceof BaseError || error instanceof Error) {\n    return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n  }\n\n  // Handle unknown errors\n  return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts"
    },
    {
      "path": "../web/src/features/auth/evm/index.tsx",
      "content": "'use client';\n\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { withClientOnly } from '@/components/utils/client-only';\nimport { ConnectWalletButton } from './components/simplekit';\nimport { useSwitchChainIfSelectedIsNotConfigured } from './useSwitchChainIfSelectedIsNotConfigured';\n\nconst EvmAuthComponentSkeleton = () => (\n  <div className=\"flex flex-col items-center gap-2\">\n    <Skeleton className=\"h-9 w-[100px]\" />\n  </div>\n);\n\nconst EvmAuthComponent = withClientOnly(\n  () => {\n    useSwitchChainIfSelectedIsNotConfigured();\n\n    return <ConnectWalletButton />;\n  },\n  () => <EvmAuthComponentSkeleton />,\n);\n\nexport default EvmAuthComponent;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/index.tsx"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/getSmartAccountClient.ts",
      "content": "import { type Chain, createPublicClient, EIP1193Provider, http, Transport } from 'viem';\nimport { createSmartAccountClient } from 'permissionless';\nimport { entryPoint07Address } from 'viem/account-abstraction';\nimport { createPimlicoClient } from 'permissionless/clients/pimlico';\nimport { toKernelSmartAccount } from 'permissionless/accounts';\n\nexport const getSmartAccountClient = async ({\n  chainId,\n  chains,\n  transports,\n  provider,\n  accountAbstractionChainConfigs,\n}: {\n  chainId: number;\n  chains: Chain[];\n  transports?: Record<number, Transport>;\n  provider: EIP1193Provider;\n  accountAbstractionChainConfigs?: {\n    chainId: number;\n    bundlerUrl: string;\n    paymasterUrl: string;\n  }[];\n}) => {\n  const selectedChain = chains.find(chain => chain.id === chainId);\n  if (!selectedChain) {\n    throw new Error(`Chain ${chainId} not found`);\n  }\n  const publicClient = createPublicClient({\n    chain: selectedChain,\n    transport: http(transports?.[chainId]?.({}).value?.url),\n  });\n\n  const smartAccount = await toKernelSmartAccount({\n    owners: [provider as EIP1193Provider],\n    client: publicClient,\n    entryPoint: {\n      address: entryPoint07Address,\n      version: '0.7',\n    },\n    index: 0n,\n  });\n\n  const accountAbstractionChainConfig = accountAbstractionChainConfigs?.find(\n    x => x.chainId === chainId,\n  );\n\n  if (!accountAbstractionChainConfig) {\n    throw new Error(`Account abstraction module not found for chain ${chainId}`);\n  }\n\n  // Use this if you use ERC-7677 paymaster\n  // const paymasterClient = createPaymasterClient({\n  //   transport: http(accountAbstractionChainConfig.paymasterUrl),\n  // });\n\n  // Use this if you use Pimlico paymaster\n  const paymasterClient = createPimlicoClient({\n    transport: http(accountAbstractionChainConfig.paymasterUrl),\n    entryPoint: {\n      address: entryPoint07Address,\n      version: '0.7',\n    },\n  });\n\n  const smartAccountClient = createSmartAccountClient({\n    bundlerTransport: http(accountAbstractionChainConfig.bundlerUrl),\n    chain: selectedChain,\n    account: smartAccount,\n    paymaster: paymasterClient,\n    userOperation: {\n      estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast,\n    },\n  });\n  return smartAccountClient;\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/getSmartAccountClient.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/WagmiProviderWithAA.tsx",
      "content": "'use client';\n\nimport { log } from '@web3auth/modal';\nimport { useWeb3Auth, useWeb3AuthDisconnect, useWeb3AuthUser } from '@web3auth/modal/react';\nimport { createElement, Fragment, PropsWithChildren, useEffect } from 'react';\nimport { type Chain, EIP1193Provider, Transport } from 'viem';\nimport {\n  Config,\n  Connection,\n  Connector,\n  CreateConnectorFn,\n  useAccountEffect,\n  useConfig as useWagmiConfig,\n  useReconnect,\n  WagmiProvider as WagmiProviderBase,\n  createConnector,\n  useChainId,\n} from 'wagmi';\nimport type { WagmiProviderProps } from 'wagmi';\nimport { evmSettlementLayerEnv } from '../env';\n\n// Account Abstraction\nimport { type SmartAccountClient } from 'permissionless';\nimport { getSmartAccountClient } from './getSmartAccountClient';\n\nconst WEB3AUTH_CONNECTOR_ID = 'web3auth';\n\nexport const authConnectionToIcon = {\n  google: 'https://unpkg.com/simple-icons@15.16.1/icons/google.svg',\n  twitter: 'https://unpkg.com/simple-icons@15.16.1/icons/x.svg',\n  facebook: 'https://unpkg.com/simple-icons@15.16.1/icons/facebook.svg',\n  reddit: 'https://unpkg.com/simple-icons@15.16.1/icons/reddit.svg',\n  discord: 'https://unpkg.com/simple-icons@15.16.1/icons/discord.svg',\n  twitch: 'https://unpkg.com/simple-icons@15.16.1/icons/twitch.svg',\n  apple: 'https://unpkg.com/simple-icons@15.16.1/icons/apple.svg',\n  github: 'https://unpkg.com/simple-icons@15.16.1/icons/github.svg',\n};\n\n// Helper to initialize connectors for the given wallets\nasync function setupConnector(\n  provider: EIP1193Provider,\n  config: Config,\n  {\n    chains,\n    currentChainId,\n    transports,\n    accountAbstractionChainConfigs,\n    authConnection,\n  }: {\n    chains: Chain[];\n    currentChainId: number;\n    transports?: Record<number, Transport> | undefined;\n    accountAbstractionChainConfigs?: {\n      chainId: number;\n      bundlerUrl: string;\n      paymasterUrl: string;\n    }[];\n    authConnection?: string;\n  },\n) {\n  let connector: Connector | CreateConnectorFn | undefined = config.connectors.find(\n    c => c.id === WEB3AUTH_CONNECTOR_ID,\n  );\n\n  if (connector) return connector;\n\n  // DIRECT W3A EOA INJECTED CONNECTOR (NO SMART ACCOUNT)\n  // connector = injected({\n  //   target: {\n  //     provider: provider,\n  //     id: WEB3AUTH_CONNECTOR_ID,\n  //     name: \"Web3Auth\",\n  //   },\n  // });\n\n  let smartAccountClient = await getSmartAccountClient({\n    chainId: currentChainId,\n    chains,\n    transports,\n    provider,\n    accountAbstractionChainConfigs,\n  });\n\n  connector = createConnector<SmartAccountClient>(config => ({\n    id: WEB3AUTH_CONNECTOR_ID,\n    name: (authConnection?.at(0)?.toUpperCase() || '') + (authConnection?.slice(1) || ''),\n    ready: true,\n    icon: authConnectionToIcon[authConnection as keyof typeof authConnectionToIcon],\n    getAccounts: async () => [smartAccountClient.account.address],\n    getChainId: async () => smartAccountClient.chain.id,\n    connect: async ({ withCapabilities } = {}) =>\n      ({\n        accounts: withCapabilities\n          ? [{ address: smartAccountClient.account.address, capabilities: {} }]\n          : [smartAccountClient.account.address],\n        chainId: smartAccountClient.chain.id,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      }) as any,\n    disconnect: async () => {},\n    getProvider: async () => smartAccountClient,\n    isAuthorized: async () => true,\n    onAccountsChanged: async () => {},\n    getClient: async () => smartAccountClient,\n    switchChain: async ({ chainId }) => {\n      smartAccountClient = await getSmartAccountClient({\n        chainId,\n        chains,\n        transports,\n        provider,\n        accountAbstractionChainConfigs,\n      });\n      config.emitter.emit('change', {\n        chainId,\n      });\n      return smartAccountClient.chain;\n    },\n    onChainChanged() {},\n    onDisconnect(): void {\n      config.emitter.emit('disconnect');\n    },\n    type: 'smartAccount',\n  }));\n\n  const result = config._internal.connectors.setup(connector);\n  config._internal.connectors.setState(current => [...current, result]);\n  return result;\n}\n\n// Helper to connect a wallet and update wagmi state\nasync function connectWeb3AuthWithWagmi(connector: Connector, config: Config) {\n  await Promise.all([\n    config.storage?.removeItem(`${connector.id}.disconnected`),\n    config.storage?.setItem('recentConnectorId', connector.id),\n  ]);\n\n  let chainId = await connector.getChainId();\n  if (!config.chains.find(c => c.id === chainId)) {\n    chainId = config.chains[0].id;\n  }\n\n  const accounts = await connector.getAccounts();\n\n  const connections: Map<string, Connection> = new Map([\n    [\n      connector.uid,\n      {\n        accounts: [accounts[0]],\n        chainId,\n        connector,\n      },\n    ],\n  ]);\n\n  config.setState(state => ({\n    ...state,\n    chainId,\n    connections,\n    current: connector.uid,\n    status: 'connected',\n  }));\n}\n\nasync function disconnectWeb3AuthFromWagmi(config: Config) {\n  config._internal.connectors.setState(prev => prev.filter(c => c.id !== WEB3AUTH_CONNECTOR_ID));\n  config.setState(state => ({\n    ...state,\n    chainId: state.chainId,\n    connections: new Map(),\n    current: null,\n    status: 'disconnected',\n  }));\n}\n\nfunction Web3AuthWagmiProvider({\n  children,\n  accountAbstractionChainConfigs,\n}: PropsWithChildren<AccountAbstractionChainConfigProps>) {\n  const { isConnected, provider } = useWeb3Auth();\n  const { disconnect } = useWeb3AuthDisconnect();\n  const wagmiConfig = useWagmiConfig();\n  const { reconnect } = useReconnect();\n  const selectedChainId = useChainId();\n  const { getUserInfo } = useWeb3AuthUser();\n\n  useAccountEffect({\n    onDisconnect: async () => {\n      log.info('Disconnected from wagmi');\n      if (isConnected) await disconnect();\n    },\n  });\n\n  useEffect(() => {\n    (async () => {\n      if (isConnected && provider) {\n        const selectedChain = wagmiConfig.chains.find(chain => chain.id === selectedChainId);\n        if (!selectedChain) {\n          log.error('Selected chain not found');\n          throw new Error('Selected chain not found');\n        }\n        const userInfo = await getUserInfo();\n        const connector = await setupConnector(provider as EIP1193Provider, wagmiConfig, {\n          authConnection: userInfo?.authConnection,\n          currentChainId: wagmiConfig.state.chainId,\n          chains: wagmiConfig.chains as unknown as Chain[],\n          accountAbstractionChainConfigs,\n        });\n        if (!connector) {\n          log.error('Failed to setup react wagmi connector');\n          throw new Error('Failed to setup connector');\n        }\n\n        await connectWeb3AuthWithWagmi(connector as Connector, wagmiConfig);\n        reconnect();\n      } else if (!isConnected) {\n        if (wagmiConfig.state.status === 'connected') {\n          await disconnectWeb3AuthFromWagmi(wagmiConfig);\n        }\n      }\n    })();\n  }, [\n    isConnected,\n    wagmiConfig,\n    provider,\n    reconnect,\n    selectedChainId,\n    getUserInfo,\n    accountAbstractionChainConfigs,\n  ]);\n\n  return createElement(Fragment, null, children);\n}\n\ninterface AccountAbstractionChainConfigProps {\n  accountAbstractionChainConfigs?: {\n    chainId: number;\n    bundlerUrl: string;\n    paymasterUrl: string;\n  }[];\n}\n\nconst evmEnv = evmSettlementLayerEnv();\n\nexport function WagmiProvider({\n  children,\n  ...props\n}: PropsWithChildren<WagmiProviderProps & AccountAbstractionChainConfigProps>) {\n  if (!evmEnv.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID) {\n    return createElement(\n      WagmiProviderBase,\n      { ...props, config: props.config, reconnectOnMount: true },\n      children,\n    );\n  }\n  return createElement(\n    WagmiProviderBase,\n    // typecast to WagmiProviderPropsBase to avoid type error\n    // as we are omitting the config prop from WagmiProviderProps\n    // and creating a new config object with the finalConfig\n    { ...props, config: props.config, reconnectOnMount: true },\n    createElement(\n      Web3AuthWagmiProvider,\n      { accountAbstractionChainConfigs: props.accountAbstractionChainConfigs },\n      children,\n    ),\n  );\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/WagmiProviderWithAA.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/useSwitchChainIfSelectedIsNotConfigured.ts",
      "content": "'use client';\n\nimport { useConfig, useConnections, useSwitchChain } from 'wagmi';\nimport { useEffect } from 'react';\n\nexport const useSwitchChainIfSelectedIsNotConfigured = () => {\n  const { switchChain } = useSwitchChain();\n  const config = useConfig();\n  const connections = useConnections();\n\n  useEffect(() => {\n    if (connections.length === 0) return;\n    const connection = connections.at(0);\n    const configuredChains = config.chains.map(chain => chain.id);\n\n    if (connection?.chainId && !configuredChains.includes(connection.chainId)) {\n      switchChain({ chainId: configuredChains[0] });\n    }\n  }, [switchChain, connections, config]);\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/useSwitchChainIfSelectedIsNotConfigured.ts"
    },
    {
      "path": "../web/src/features/auth/evm/components/simplekit.tsx",
      "content": "/* eslint-disable @next/next/no-img-element */\n'use client';\n\nimport * as React from 'react';\n\nimport {\n  SimpleKitModal,\n  SimpleKitModalBody,\n  SimpleKitModalContent,\n  SimpleKitModalDescription,\n  SimpleKitModalFooter,\n  SimpleKitModalHeader,\n  SimpleKitModalTitle,\n} from './simplekit-modal';\nimport { Button } from '@/components/ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport {\n  type Connector,\n  useAccount,\n  useConnect,\n  useDisconnect,\n  useEnsAvatar,\n  useEnsName,\n  useBalance,\n  useChains,\n  useChainId,\n  useSwitchChain,\n} from 'wagmi';\nimport { formatEther } from 'viem';\nimport { Check, ChevronDown, ChevronLeft, Copy, RotateCcw } from 'lucide-react';\nimport { ChainLogo } from './chain-logos';\nimport { useTranslations } from 'next-intl';\nimport { useEvmChainConfigs } from '@/_fundset/settlement-layer/evm';\nimport { useWeb3AuthConnect } from '@web3auth/modal/react';\nimport { MfaLevelType, WALLET_CONNECTORS } from '@web3auth/modal';\nimport { authConnectionToIcon } from '@/_fundset/settlement-layer/evm/connectors/WagmiProviderWithAA';\nimport { ensureDefined } from '@/lib/ensureDefined';\nimport { evmSettlementLayerEnv } from '@/_fundset/settlement-layer/evm/env';\n\nconst MODAL_CLOSE_DURATION = 320;\n\nconst SimpleKitContext = React.createContext<{\n  pendingConnector: Pick<Connector, 'name' | 'icon'> | null;\n  setPendingConnector: React.Dispatch<\n    React.SetStateAction<Pick<Connector, 'name' | 'icon'> | null>\n  >;\n  isConnectorError: boolean;\n  setIsConnectorError: React.Dispatch<React.SetStateAction<boolean>>;\n  open: boolean;\n  setOpen: React.Dispatch<React.SetStateAction<boolean>>;\n}>({\n  pendingConnector: null,\n  setPendingConnector: () => null,\n  isConnectorError: false,\n  setIsConnectorError: () => false,\n  open: false,\n  setOpen: () => false,\n});\n\nfunction SimpleKitProvider(props: { children: React.ReactNode }) {\n  const { status, address } = useAccount();\n  const [pendingConnector, setPendingConnector] = React.useState<Pick<\n    Connector,\n    'name' | 'icon'\n  > | null>(null);\n  const [isConnectorError, setIsConnectorError] = React.useState(false);\n  const [open, setOpen] = React.useState(false);\n  const isConnected = address && !pendingConnector;\n\n  React.useEffect(() => {\n    if (status === 'connected' && pendingConnector) {\n      setOpen(false);\n\n      const timeout = setTimeout(() => {\n        setPendingConnector(null);\n        setIsConnectorError(false);\n      }, MODAL_CLOSE_DURATION);\n\n      return () => clearTimeout(timeout);\n    }\n  }, [status, setOpen, pendingConnector, setPendingConnector]);\n\n  return (\n    <SimpleKitContext.Provider\n      value={{\n        pendingConnector,\n        setPendingConnector,\n        isConnectorError,\n        setIsConnectorError,\n        open,\n        setOpen,\n      }}\n    >\n      {props.children}\n      <SimpleKitModal open={open} onOpenChange={setOpen}>\n        <SimpleKitModalContent>{isConnected ? <Account /> : <Connectors />}</SimpleKitModalContent>\n      </SimpleKitModal>\n    </SimpleKitContext.Provider>\n  );\n}\n\nfunction ConnectWalletButton() {\n  const simplekit = useSimpleKit();\n  const { address } = useAccount();\n  const { data: ensName } = useEnsName({ address });\n  const { data: ensAvatar } = useEnsAvatar({ name: ensName! });\n  const t = useTranslations('Auth');\n\n  return (\n    <Button onClick={simplekit.toggleModal} className=\"rounded-xl\">\n      {simplekit.isConnected ? (\n        <>\n          {ensAvatar && <img src={ensAvatar} alt=\"ENS Avatar\" />}\n          {address && <span>{ensName ? `${ensName}` : simplekit.formattedAddress}</span>}\n        </>\n      ) : (\n        t('login')\n      )}\n    </Button>\n  );\n}\n\nfunction Account() {\n  const { address } = useAccount();\n  const { disconnect } = useDisconnect();\n  const { data: ensName } = useEnsName({ address });\n  const { data: userBalance } = useBalance({ address });\n  const context = React.useContext(SimpleKitContext);\n  const chains = useChains();\n  const selectedChainId = useChainId();\n  const { switchChain, isPending: isSwitching } = useSwitchChain();\n  const t = useTranslations('Auth');\n\n  const formattedAddress = address?.slice(0, 6) + '•••' + address?.slice(-4);\n  const formattedUserBalace = userBalance?.value\n    ? parseFloat(formatEther(userBalance.value)).toFixed(4)\n    : undefined;\n\n  function handleDisconnect() {\n    context.setOpen(false);\n    setTimeout(() => {\n      disconnect();\n    }, MODAL_CLOSE_DURATION);\n  }\n\n  return (\n    <>\n      <SimpleKitModalHeader>\n        <SimpleKitModalTitle>{t('your_account')}</SimpleKitModalTitle>\n        <SimpleKitModalDescription className=\"sr-only\">\n          Account modal for your connected Web3 wallet.\n        </SimpleKitModalDescription>\n      </SimpleKitModalHeader>\n      <SimpleKitModalBody className=\"h-[280px]\">\n        <div className=\"flex w-full flex-col items-center justify-center gap-8 md:pt-5\">\n          <div className=\"relative flex size-24 items-center justify-center\">\n            <img\n              className=\"rounded-full\"\n              src={`https://avatar.vercel.sh/${address}?size=150`}\n              alt=\"User gradient avatar\"\n            />\n            <div className=\"absolute right-0 -bottom-2\">\n              <DropdownMenu>\n                <DropdownMenuTrigger asChild>\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    className=\"h-7 gap-1 rounded-full !px-0 !py-0\"\n                    disabled={isSwitching}\n                  >\n                    <ChainLogo key={selectedChainId} chainId={selectedChainId} />\n\n                    <ChevronDown className=\"mr-2 size-4\" />\n                  </Button>\n                </DropdownMenuTrigger>\n                <DropdownMenuContent align=\"end\" className=\"w-48\">\n                  {chains.map(chain => (\n                    <DropdownMenuItem\n                      key={chain.id}\n                      onClick={() => {\n                        if (chain.id !== selectedChainId) {\n                          switchChain({ chainId: chain.id });\n                        }\n                      }}\n                    >\n                      {chain.name}\n                      {chain.id === selectedChainId && <Check className=\"ml-auto size-4\" />}\n                    </DropdownMenuItem>\n                  ))}\n                </DropdownMenuContent>\n              </DropdownMenu>\n            </div>\n          </div>\n\n          <div className=\"space-y-1 px-3.5 text-center sm:px-0\">\n            <div className=\"flex items-center gap-1.5\">\n              <h1 className=\"text-xl font-semibold\">\n                <div>{ensName ? `${ensName}` : formattedAddress}</div>\n              </h1>\n              <CopyAddressButton />\n            </div>\n            <p className=\"text-muted-foreground text-sm text-balance\">\n              {`${formattedUserBalace ?? '0.00'} ETH`}\n            </p>\n          </div>\n\n          <Button className=\"w-full rounded-xl\" onClick={handleDisconnect}>\n            {t('disconnect')}\n          </Button>\n        </div>\n      </SimpleKitModalBody>\n    </>\n  );\n}\n\nfunction Connectors() {\n  const context = React.useContext(SimpleKitContext);\n  const t = useTranslations('Auth');\n  return (\n    <>\n      <SimpleKitModalHeader>\n        <BackChevron />\n        <SimpleKitModalTitle>{context.pendingConnector?.name ?? t('login')}</SimpleKitModalTitle>\n        <SimpleKitModalDescription className=\"sr-only\">\n          {t('login_description')}\n        </SimpleKitModalDescription>\n      </SimpleKitModalHeader>\n      <SimpleKitModalBody>\n        {context.pendingConnector ? <WalletConnecting /> : <WalletOptions />}\n      </SimpleKitModalBody>\n      <SimpleKitModalFooter>\n        <div className=\"h-0\" />\n      </SimpleKitModalFooter>\n    </>\n  );\n}\n\nfunction WalletConnecting() {\n  const context = React.useContext(SimpleKitContext);\n  const t = useTranslations('Errors');\n  const tAuth = useTranslations('Auth');\n\n  return (\n    <div className=\"flex w-full flex-col items-center justify-center gap-9 md:pt-5\">\n      {context.pendingConnector?.icon && (\n        <div className=\"relative flex size-[116px] items-center justify-center rounded-2xl border p-3\">\n          <img\n            src={context.pendingConnector?.icon}\n            alt={context.pendingConnector?.name}\n            className=\"size-full overflow-hidden rounded-2xl\"\n          />\n          {context.isConnectorError ? <RetryConnectorButton /> : null}\n        </div>\n      )}\n\n      <div className=\"space-y-3.5 px-3.5 text-center sm:px-0\">\n        <h1 className=\"text-xl font-semibold\">\n          {context.isConnectorError ? t('UNKNOWN_ERROR') : tAuth('loading')}\n        </h1>\n        <p className=\"text-muted-foreground text-sm text-balance\">\n          {context.isConnectorError\n            ? tAuth('login_error')\n            : tAuth('waiting_for_connector', { connector: context.pendingConnector?.name ?? '' })}\n        </p>\n      </div>\n    </div>\n  );\n}\n\nfunction WalletOptions() {\n  const context = React.useContext(SimpleKitContext);\n  const { connectors, connect } = useConnectors();\n  const chainConfigs = useEvmChainConfigs();\n  const chainId = useChainId();\n\n  const accountAbstractionConnectors = React.useMemo(() => {\n    if (!evmSettlementLayerEnv().NEXT_PUBLIC_WEB3AUTH_CLIENT_ID) {\n      return [];\n    }\n    return ensureDefined(\n      chainConfigs\n        .filter(chainConfig => chainConfig.chainId === chainId)\n        .flatMap(chainConfig =>\n          chainConfig.modules\n            .find(module => module.blockType === 'evm-aa-module')\n            ?.providers.map(({ provider, mfaLevel }) => {\n              return {\n                web3auth: true,\n                name: provider.charAt(0).toUpperCase() + provider.slice(1),\n                provider,\n                mfaLevel,\n                icon: authConnectionToIcon[provider as keyof typeof authConnectionToIcon],\n              };\n            }),\n        ),\n    );\n  }, [chainConfigs, chainId]);\n\n  return (\n    <div className=\"flex flex-col gap-3.5\">\n      {connectors.map(connector => (\n        <WalletOption\n          key={connector.id}\n          connector={connector}\n          onClick={() => {\n            context.setIsConnectorError(false);\n            context.setPendingConnector(connector);\n            connect({ connector });\n          }}\n        />\n      ))}\n      {accountAbstractionConnectors.map(connector => (\n        <AccountAbstractionOption\n          key={connector.name}\n          name={connector.name}\n          icon={connector.icon}\n          onClick={async () => {\n            context.setIsConnectorError(false);\n            context.setPendingConnector(connector);\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction WalletOption(props: { connector: Connector; onClick: () => void }) {\n  return (\n    <Button\n      onClick={props.onClick}\n      size=\"lg\"\n      variant=\"secondary\"\n      className=\"justify-between rounded-xl px-4 py-7 text-base font-semibold\"\n    >\n      <p>{props.connector.name}</p>\n      {props.connector.icon && (\n        <img\n          src={props.connector.icon}\n          alt={props.connector.name}\n          className=\"size-8 overflow-hidden rounded-[6px]\"\n        />\n      )}\n    </Button>\n  );\n}\n\nfunction AccountAbstractionOption(props: {\n  name?: string;\n  icon?: string;\n  provider?: string;\n  mfaLevel?: MfaLevelType;\n  onClick: () => void;\n}) {\n  const { connectTo } = useWeb3AuthConnect();\n  return (\n    <Button\n      onClick={() => {\n        props.onClick();\n        connectTo(WALLET_CONNECTORS.AUTH, {\n          authConnection: props.provider,\n          mfaLevel: props.mfaLevel,\n        });\n      }}\n      size=\"lg\"\n      variant=\"secondary\"\n      className=\"justify-between rounded-xl px-4 py-7 text-base font-semibold\"\n    >\n      <p>{props.name}</p>\n      {props.icon && (\n        <img src={props.icon} alt={props.name} className=\"size-8 overflow-hidden rounded-[6px]\" />\n      )}\n    </Button>\n  );\n}\n\nfunction CopyAddressButton() {\n  const { address } = useAccount();\n  const [copied, setCopied] = React.useState(false);\n\n  React.useEffect(() => {\n    const timeout = setTimeout(() => {\n      if (copied) setCopied(false);\n    }, 1000);\n    return () => clearTimeout(timeout);\n  }, [copied, setCopied]);\n\n  async function handleCopy() {\n    setCopied(true);\n    await navigator.clipboard.writeText(address!);\n  }\n\n  return (\n    <button className=\"text-muted-foreground\" onClick={handleCopy}>\n      {copied ? (\n        <Check className=\"size-4\" strokeWidth={4} />\n      ) : (\n        <Copy className=\"size-4\" strokeWidth={4} />\n      )}\n    </button>\n  );\n}\n\nfunction BackChevron() {\n  const context = React.useContext(SimpleKitContext);\n\n  if (!context.pendingConnector) {\n    return null;\n  }\n\n  function handleClick() {\n    context.setIsConnectorError(false);\n    context.setPendingConnector(null);\n  }\n\n  return (\n    <button\n      className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-[42px] left-[26px] z-50 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-none disabled:pointer-events-none md:top-[26px]\"\n      onClick={handleClick}\n    >\n      <ChevronLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Cancel connection</span>\n    </button>\n  );\n}\n\nfunction RetryConnectorButton() {\n  const context = React.useContext(SimpleKitContext);\n  const { connect } = useConnect({\n    mutation: {\n      onError: () => context.setIsConnectorError(true),\n    },\n  });\n\n  function handleClick() {\n    if (context.pendingConnector) {\n      context.setIsConnectorError(false);\n      connect({ connector: context.pendingConnector as Connector });\n    }\n  }\n\n  return (\n    <Button\n      size=\"icon\"\n      variant=\"secondary\"\n      className=\"group bg-muted absolute -right-2 -bottom-2 rounded-full p-1.5 shadow\"\n      onClick={handleClick}\n    >\n      <RotateCcw className=\"size-4 transition-transform group-hover:-rotate-45\" />\n    </Button>\n  );\n}\n\nfunction useConnectors() {\n  const context = React.useContext(SimpleKitContext);\n  const { connect, connectors } = useConnect({\n    mutation: {\n      onError: error => {\n        console.error(error);\n        context.setIsConnectorError(true);\n      },\n    },\n  });\n\n  const sortedConnectors = React.useMemo(() => {\n    let metaMaskConnector: Connector | undefined;\n    let injectedConnector: Connector | undefined;\n\n    const formattedConnectors = connectors.reduce((acc: Array<Connector>, curr) => {\n      switch (curr.id) {\n        case 'metaMaskSDK':\n          metaMaskConnector = {\n            ...curr,\n            icon: 'https://utfs.io/f/be0bd88f-ce87-4cbc-b2e5-c578fa866173-sq4a0b.png',\n          };\n          return acc;\n        case 'metaMask':\n          injectedConnector = {\n            ...curr,\n            icon: 'https://utfs.io/f/be0bd88f-ce87-4cbc-b2e5-c578fa866173-sq4a0b.png',\n          };\n          return acc;\n        case 'safe':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/164ea200-3e15-4a9b-9ce5-a397894c442a-awpd29.png',\n          });\n          return acc;\n        case 'coinbaseWalletSDK':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/53e47f86-5f12-404f-a98b-19dc7b760333-chngxw.png',\n          });\n          return acc;\n        case 'walletConnect':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/5bfaa4d1-b872-48a7-9d37-c2517d4fc07a-utlf4g.png',\n          });\n          return acc;\n        default:\n          acc.unshift(curr);\n          return acc;\n      }\n    }, []);\n\n    if (\n      metaMaskConnector &&\n      !formattedConnectors.find(\n        ({ id }) => id === 'io.metamask' || id === 'io.metamask.mobile' || id === 'injected',\n      )\n    ) {\n      return [metaMaskConnector, ...formattedConnectors];\n    }\n\n    if (injectedConnector) {\n      const nonMetaMaskConnectors = formattedConnectors.filter(\n        ({ id }) => id !== 'io.metamask' && id !== 'io.metamask.mobile',\n      );\n      return [injectedConnector, ...nonMetaMaskConnectors];\n    }\n    return formattedConnectors;\n  }, [connectors]);\n\n  return { connectors: sortedConnectors, connect };\n}\n\n/*\n * This hook can be moved to a separate file\n * if desired (src/hooks/use-simple-kit.tsx).\n */\nfunction useSimpleKit() {\n  const { address } = useAccount();\n  const context = React.useContext(SimpleKitContext);\n\n  const isModalOpen = context.open;\n  const isConnected = address && !context.pendingConnector;\n  const formattedAddress = address?.slice(0, 6) + '•••' + address?.slice(-4);\n\n  function open() {\n    context.setOpen(true);\n  }\n\n  function close() {\n    context.setOpen(false);\n  }\n\n  function toggleModal() {\n    context.setOpen(prevState => !prevState);\n  }\n\n  return {\n    isModalOpen,\n    isConnected,\n    formattedAddress,\n    open,\n    close,\n    toggleModal,\n  };\n}\n\nexport { SimpleKitProvider, ConnectWalletButton, useSimpleKit, SimpleKitContext };\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/simplekit.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/components/simplekit-modal.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@/lib/utils';\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from '@/components/ui/dialog';\nimport {\n  Drawer,\n  DrawerClose,\n  DrawerContent,\n  DrawerDescription,\n  DrawerFooter,\n  DrawerHeader,\n  DrawerTitle,\n  DrawerTrigger,\n} from '@/components/ui/drawer';\nimport { ScrollArea } from '@/components/ui/scroll-area';\n\ninterface BaseProps {\n  children: React.ReactNode;\n}\n\ninterface RootSimpleKitModalProps extends BaseProps {\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n}\n\ninterface SimpleKitModalProps extends BaseProps {\n  className?: string;\n  asChild?: true;\n}\n\nconst desktop = '(min-width: 768px)';\n\nconst SimpleKitModal = ({ children, ...props }: RootSimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModal = isDesktop ? Dialog : Drawer;\n\n  return <SimpleKitModal {...props}>{children}</SimpleKitModal>;\n};\n\nconst SimpleKitModalTrigger = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalTrigger = isDesktop ? DialogTrigger : DrawerTrigger;\n\n  return (\n    <SimpleKitModalTrigger className={className} {...props}>\n      {children}\n    </SimpleKitModalTrigger>\n  );\n};\n\nconst SimpleKitModalClose = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalClose = isDesktop ? DialogClose : DrawerClose;\n\n  return (\n    <SimpleKitModalClose className={className} {...props}>\n      {children}\n    </SimpleKitModalClose>\n  );\n};\n\nconst SimpleKitModalContent = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalContent = isDesktop ? DialogContent : DrawerContent;\n\n  return (\n    <SimpleKitModalContent\n      className={cn(\n        'rounded-t-3xl sm:rounded-3xl md:max-w-[360px] [&>button]:top-[26px] [&>button]:right-[26px]',\n        className,\n      )}\n      onOpenAutoFocus={e => e.preventDefault()}\n      {...props}\n    >\n      {children}\n    </SimpleKitModalContent>\n  );\n};\n\nconst SimpleKitModalDescription = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalDescription = isDesktop ? DialogDescription : DrawerDescription;\n\n  return (\n    <SimpleKitModalDescription className={className} {...props}>\n      {children}\n    </SimpleKitModalDescription>\n  );\n};\n\nconst SimpleKitModalHeader = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalHeader = isDesktop ? DialogHeader : DrawerHeader;\n\n  return (\n    <SimpleKitModalHeader className={cn('space-y-0 pb-6 md:pb-3', className)} {...props}>\n      {children}\n    </SimpleKitModalHeader>\n  );\n};\n\nconst SimpleKitModalTitle = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalTitle = isDesktop ? DialogTitle : DrawerTitle;\n\n  return (\n    <SimpleKitModalTitle className={cn('text-center', className)} {...props}>\n      {children}\n    </SimpleKitModalTitle>\n  );\n};\n\nconst SimpleKitModalBody = ({ className, children, ...props }: SimpleKitModalProps) => {\n  return (\n    <ScrollArea\n      className={cn(\n        'h-[234px] max-h-[300px] px-6 md:-mr-4 md:h-full md:min-h-[260px] md:px-0 md:pr-4',\n        className,\n      )}\n      {...props}\n    >\n      {children}\n    </ScrollArea>\n  );\n};\n\nconst SimpleKitModalFooter = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalFooter = isDesktop ? DialogFooter : DrawerFooter;\n\n  return (\n    <SimpleKitModalFooter className={cn('py-3.5 md:py-0', className)} {...props}>\n      {children}\n    </SimpleKitModalFooter>\n  );\n};\n\nexport {\n  SimpleKitModal,\n  SimpleKitModalTrigger,\n  SimpleKitModalClose,\n  SimpleKitModalContent,\n  SimpleKitModalDescription,\n  SimpleKitModalHeader,\n  SimpleKitModalTitle,\n  SimpleKitModalBody,\n  SimpleKitModalFooter,\n};\n\n/*\n * Hook used to calculate the width of the screen using the\n * MediaQueryListEvent. This can be moved to a separate file\n * if desired (src/hooks/use-media-query.tsx).\n */\nexport function useMediaQuery(query: string) {\n  const [value, setValue] = React.useState(false);\n\n  React.useEffect(() => {\n    function onChange(event: MediaQueryListEvent) {\n      setValue(event.matches);\n    }\n\n    const result = matchMedia(query);\n    result.addEventListener('change', onChange);\n    setValue(result.matches);\n\n    return () => result.removeEventListener('change', onChange);\n  }, [query]);\n\n  return value;\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/simplekit-modal.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/components/chain-logos.tsx",
      "content": "import React from 'react';\nimport { useChains } from 'wagmi';\n\nconst KnownChain = ({ ...props }: React.SVGProps<SVGSVGElement>) => (\n  <svg\n    {...props}\n    aria-hidden=\"true\"\n    width=\"44\"\n    height=\"44\"\n    viewBox=\"0 0 44 44\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    style={{\n      background: 'linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)',\n    }}\n  >\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M20.5611 8.12948C21.0082 7.90729 21.5007 7.79167 22 7.79167C22.4993 7.79167 22.9919 7.90729 23.439 8.12948L23.4408 8.1304L33.0387 12.9293C33.577 13.197 34.031 13.61 34.3478 14.121C34.6649 14.6323 34.833 15.2218 34.8333 15.8234V27.2595C34.833 27.8611 34.6649 28.4511 34.3478 28.9624C34.031 29.4733 33.578 29.8858 33.0398 30.1535L23.4411 34.9528C22.9919 35.1775 22.4963 35.2947 21.994 35.2947C21.4918 35.2947 20.9964 35.1777 20.5472 34.9529L10.9475 30.1531L10.9452 30.1519C10.4071 29.8808 9.95535 29.4646 9.6411 28.9504C9.32739 28.437 9.16312 27.8464 9.16673 27.2448L9.16675 27.2417L10.0004 27.2475H9.16673V27.2448V15.8239C9.16705 15.2223 9.33518 14.6322 9.65222 14.121C9.96906 13.61 10.4221 13.1976 10.9604 12.9298L20.5592 8.1304L20.5611 8.12948ZM21.3031 9.62267L11.8706 14.3389L22 19.4036L32.1294 14.3389L22.697 9.62267C22.4806 9.51531 22.2416 9.45905 22 9.45905C21.7585 9.45905 21.5194 9.51534 21.3031 9.62267ZM10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241ZM22.8337 33.3923L32.2967 28.6608C32.5576 28.5312 32.7772 28.3313 32.9308 28.0836C33.0844 27.836 33.1658 27.5504 33.166 27.259V15.8243C33.1659 15.7786 33.1639 15.7331 33.1599 15.6878L22.8337 20.8509V33.3923Z\"\n      fill=\"url(#paint0_linear_3546_7073)\"\n    />\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241Z\"\n      fill=\"url(#paint1_linear_3546_7073)\"\n      fillOpacity=\"0.3\"\n    />\n    <defs>\n      <linearGradient\n        id=\"paint0_linear_3546_7073\"\n        x1=\"22\"\n        y1=\"7.79167\"\n        x2=\"22\"\n        y2=\"35.2947\"\n        gradientUnits=\"userSpaceOnUse\"\n      >\n        <stop stopColor=\"white\" />\n        <stop offset=\"1\" stopColor=\"white\" stopOpacity=\"0.7\" />\n      </linearGradient>\n      <linearGradient\n        id=\"paint1_linear_3546_7073\"\n        x1=\"22\"\n        y1=\"7.79167\"\n        x2=\"22\"\n        y2=\"35.2947\"\n        gradientUnits=\"userSpaceOnUse\"\n      >\n        <stop stopColor=\"white\" />\n        <stop offset=\"1\" stopColor=\"white\" stopOpacity=\"0.7\" />\n      </linearGradient>\n    </defs>\n  </svg>\n);\n\nexport function ChainLogo({\n  chainId,\n  size = 28,\n  title,\n  style,\n}: {\n  chainId: number;\n  size?: number;\n  title?: string;\n  style?: React.CSSProperties;\n}) {\n  const chains = useChains();\n  const chain = chains.find(chain => chain.id === chainId);\n  const [srcIndex, setSrcIndex] = React.useState<number>(0);\n\n  const urls = [\n    chain?.name.toLowerCase(),\n    chain?.name.split(' ').join('').toLowerCase(),\n    chain?.name.split(' ').slice(0, 1).join('').toLowerCase(),\n  ]\n    .filter((name, index, arr) => name && arr.indexOf(name) === index) // remove duplicates\n    .map(\n      name =>\n        `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/${name}/info/logo.png`,\n    );\n\n  if (!chain || srcIndex >= urls.length) {\n    return <KnownChain className=\"!h-full !w-7 rounded-full\" />;\n  }\n\n  return (\n    // eslint-disable-next-line @next/next/no-img-element\n    <img\n      src={urls[srcIndex]}\n      alt={title ?? `Chain ${chainId}`}\n      width={size}\n      height={size}\n      style={{ display: 'inline-block', verticalAlign: 'middle', borderRadius: 6, ...style }}\n      onError={() => setSrcIndex(srcIndex => srcIndex + 1)}\n      loading=\"lazy\"\n      decoding=\"async\"\n      className=\"rounded-full\"\n    />\n  );\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/chain-logos.tsx"
    },
    {
      "path": "../evm/indexer/src/EventHandlers.ts",
      "content": "/*\n * Please refer to https://docs.envio.dev for a thorough guide on all Envio indexer features\n */\n\nimport {\n  DiamondProxy,\n  DiamondProxy_DiamondCut,\n  DiamondProxy_OwnershipTransferred,\n} from 'generated';\nimport './modules';\n\nDiamondProxy.DiamondCut.handler(async ({ event, context }) => {\n  for (const facetCut of event.params.facetCuts) {\n    const [facetAddress, action, functionSelectors] = facetCut;\n    const entity: DiamondProxy_DiamondCut = {\n      id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n      diamondAction: action,\n      init: event.params.data,\n      calldata: event.params.data,\n      facetAddress: facetAddress.toString(),\n      functionSelectors: functionSelectors.map(selector => selector.toString()),\n    };\n    context.DiamondProxy_DiamondCut.set(entity);\n  }\n});\n\nDiamondProxy.OwnershipTransferred.handler(async ({ event, context }) => {\n  const entity: DiamondProxy_OwnershipTransferred = {\n    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n    newOwner: event.params.newOwner,\n    previousOwner: event.params.previousOwner,\n  };\n  context.DiamondProxy_OwnershipTransferred.set(entity);\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/indexer/src/EventHandlers.ts"
    }
  ],
  "meta": {
    "dependencies": {
      "web": [
        "zod",
        "@t3-oss/env-nextjs",
        "wagmi",
        "viem",
        "@web3auth/modal",
        "permissionless",
        "@uidotdev/usehooks"
      ]
    }
  }
}
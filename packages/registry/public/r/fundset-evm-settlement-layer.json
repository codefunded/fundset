{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fundset-evm-settlement-layer",
  "type": "registry:item",
  "title": "fundset-evm-settlement-layer",
  "description": "fundset-evm-settlement-layer",
  "registryDependencies": [
    "https://fundset.vercel.app/r/fundset-core.json"
  ],
  "files": [
    {
      "path": "../evm/contracts/contracts/DiamondProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport { SolidStateDiamond } from '@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol';\n\ncontract DiamondProxy is SolidStateDiamond {}\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/contracts/DiamondProxy.sol"
    },
    {
      "path": "../evm/contracts/ignition/modules/DiamondProxy.ts",
      "content": "import { buildModule } from '@nomicfoundation/hardhat-ignition/modules';\n\nexport const DiamondProxyModule = buildModule('DiamondProxyModule', m => {\n  const diamondProxy = m.contract('DiamondProxy');\n\n  return { diamondProxy };\n});\n\nexport default DiamondProxyModule;\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/ignition/modules/DiamondProxy.ts"
    },
    {
      "path": "../evm/contracts/test/DiamondProxy.ts",
      "content": "import { describe, it } from 'node:test';\nimport { network } from 'hardhat';\n// We don't have Ethereum specific assertions in Hardhat 3 yet\nimport assert from 'node:assert/strict';\nimport DiamondProxyModule from '../ignition/modules/DiamondProxy.ts';\nimport { toFunctionSelector, WriteContractErrorType, zeroAddress } from 'viem';\nimport CounterVersionsModule from '../ignition/modules/CounterVersions.ts';\nimport { DIAMOND_ACTIONS } from '../types/diamond-action.ts';\n\ndescribe('DiamondProxy', async function () {\n  const { viem, ignition } = await network.connect();\n\n  it('should allow to increment the counter with V1 and V2 after attaching them to the diamond proxy', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV1, counterV2 } = await ignition.deploy(CounterVersionsModule);\n\n    const selectorsV1 = counterV1.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    // attach Counter V1\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV1.address, selectors: selectorsV1 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV1 = await viem.getContractAt('CounterV1', diamondProxy.address);\n    assert.equal(await diamondWithCounterV1.read.x(), 0n);\n    await diamondWithCounterV1.write.inc();\n    assert.equal(await diamondWithCounterV1.read.x(), 1n);\n\n    // Try running V2 before attaching, should fail\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await assert.rejects(diamondWithCounterV2.write.incBy([10n]), (err: WriteContractErrorType) =>\n      err.message.includes('Proxy__ImplementationIsNotContract()'),\n    );\n\n    // attach Counter V2\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    // should work now\n    await diamondWithCounterV2.write.incBy([10n]);\n    assert.equal(await diamondWithCounterV1.read.x(), 11n);\n  });\n\n  it('should allow to increment the counter per address', async function () {\n    const { diamondProxy } = await ignition.deploy(DiamondProxyModule);\n    const { counterV2 } = await ignition.deploy(CounterVersionsModule);\n    const [walletClient] = await viem.getWalletClients();\n\n    const selectorsV2 = counterV2.abi\n      .filter(abi => abi.type === 'function')\n      .map(abi => toFunctionSelector(abi));\n\n    await diamondProxy.write.diamondCut([\n      [{ action: DIAMOND_ACTIONS.ADD, target: counterV2.address, selectors: selectorsV2 }],\n      zeroAddress,\n      '0x',\n    ]);\n\n    const diamondWithCounterV2 = await viem.getContractAt('CounterV2', diamondProxy.address);\n    await diamondWithCounterV2.write.incByAddress([10n]);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([walletClient.account.address]), 10n);\n    assert.equal(await diamondWithCounterV2.read.xByAddress([zeroAddress]), 0n);\n  });\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/contracts/test/DiamondProxy.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/index.tsx",
      "content": "'use client';\n\nimport { useEffect, useMemo } from 'react';\nimport * as viem from 'viem';\nimport * as chains from 'wagmi/chains';\nimport { type Chain } from 'wagmi/chains';\nimport { createConfig, WagmiProvider } from 'wagmi';\nimport type { EvmSettlementLayerConfig } from './config.type';\n\nexport * from './config.type';\nexport * from './connectors/web3auth';\n\nimport { createContext, useContext } from 'react';\nimport { SimpleKitProvider } from '@/features/auth/evm/components/simplekit';\nimport { getWeb3AuthConnector } from './connectors/web3auth/providers';\n\nexport const EvmChainConfigsContext = createContext<\n  EvmSettlementLayerConfig['chainConfigs'] | null\n>(null);\n\nexport const useEvmChainConfigs = () => {\n  const config = useContext(EvmChainConfigsContext);\n  if (!config) {\n    throw new Error('EvmChainConfigsContext not found');\n  }\n  return config;\n};\n\nexport const EvmChainConfigsProvider = ({\n  children,\n  config,\n}: React.PropsWithChildren<{\n  config: EvmSettlementLayerConfig['chainConfigs'];\n}>) => {\n  return (\n    <EvmChainConfigsContext.Provider value={config}>{children}</EvmChainConfigsContext.Provider>\n  );\n};\n\nconst EvmSettlementLayerProvider = ({\n  children,\n  ...props\n}: React.PropsWithChildren<{ config: EvmSettlementLayerConfig }>) => {\n  const { wagmiConfig } = useMemo(() => {\n    const configChains = props.config.chainConfigs.map(chain =>\n      Object.values(chains).find(c => c.id === chain.chainId),\n    );\n\n    if (configChains.length === 0) {\n      throw new Error(\n        `Chains [${props.config.chainConfigs.map(c => c.chainId).join(', ')}] not found`,\n      );\n    }\n\n    const transports = props.config.chainConfigs.reduce(\n      (acc, chain) => ({\n        ...acc,\n        [chain.chainId]: viem.http(chain.rpcUrl, {\n          retryCount: 5,\n          retryDelay: 200,\n          batch: { wait: 100 },\n        }),\n      }),\n      {} as Record<number, viem.HttpTransport<undefined, false>>,\n    );\n\n    const socialConnectors = props.config.chainConfigs.flatMap(\n      chain =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n        chain.modules\n          .find(module => module.blockType === 'evm-aa-module')\n          ?.providers.map(({ provider }) =>\n            getWeb3AuthConnector({\n              chains: configChains as unknown as Chain[],\n              chainConfigs: props.config.chainConfigs,\n              selectedChainId: chain.chainId,\n              provider,\n              customRpcUrl: transports?.[chain.chainId]?.({}).value?.url,\n            }),\n          )\n          .filter(Boolean)!,\n    );\n\n    return {\n      wagmiConfig: createConfig({\n        chains: configChains as unknown as readonly [Chain, ...Chain[]],\n        transports,\n        ssr: true,\n        multiInjectedProviderDiscovery: true,\n        pollingInterval: 1000,\n        connectors: [...socialConnectors],\n      }),\n    };\n  }, [props.config.chainConfigs]);\n\n  useEffect(function hotContractReload() {\n    if (process.env.NODE_ENV === 'development') {\n      const wss = new WebSocket('http://localhost:9999');\n      wss.onopen = () => {\n        console.log('Hot Contract Reload: WebSocket connection established');\n      };\n      wss.onmessage = event => {\n        if (event.data === 'reload') {\n          window.location.reload();\n        }\n      };\n      return () => {\n        console.log('Hot Contract Reload: WebSocket connection closed');\n        wss.close();\n      };\n    }\n  }, []);\n\n  return (\n    <WagmiProvider config={wagmiConfig}>\n      <EvmChainConfigsProvider config={props.config.chainConfigs}>\n        <SimpleKitProvider>{children}</SimpleKitProvider>\n      </EvmChainConfigsProvider>\n    </WagmiProvider>\n  );\n};\n\nexport default EvmSettlementLayerProvider;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/index.tsx"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts",
      "content": "'use client';\n\nimport { useChainId, useConfig, useWalletClient } from 'wagmi';\nimport { SettlementLayer } from 'fundset/settlement-layer';\nimport { useMemo } from 'react';\nimport { buildCounterModule } from './modules/counter';\nimport { EvmChainModules, EvmModule } from './config.type';\nimport * as chains from 'wagmi/chains';\nimport { useEvmChainConfigs } from '.';\n\nexport const useEvmSettlementLayer = () => {\n  const evmChainConfigs = useEvmChainConfigs();\n  const { data: walletClient } = useWalletClient();\n  const config = useConfig();\n  const chainId = useChainId();\n\n  const evmModules = useMemo(() => {\n    return evmChainConfigs.reduce((acc, chainConfig) => {\n      acc[chainConfig.chainId] = {\n        proxyAddress: chainConfig.proxyAddress,\n        contracts: chainConfig.modules.reduce(\n          (contractsAcc, module) => {\n            if ('contracts' in module) {\n              module.contracts.forEach(contract => {\n                Object.entries(contract).forEach(([key, value]) => {\n                  if (key === 'id' || value === null) {\n                    return;\n                  }\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  (contractsAcc as any)[key] = value as `0x${string}`;\n                });\n              });\n            }\n            return contractsAcc;\n          },\n          {} as EvmModule['contracts'],\n        ),\n      };\n      return acc;\n    }, {} as EvmChainModules);\n  }, [evmChainConfigs]);\n\n  const evmSettlementLayer: SettlementLayer = useMemo(() => {\n    const chain = Object.values(chains).find(c => c.id === chainId) as chains.Chain;\n\n    const evmModule = evmModules[chainId];\n    if (!evmModule) {\n      throw new Error(`Evm module not found for chainId: ${chainId}`);\n    }\n\n    return {\n      name: 'evm',\n      ...buildCounterModule({\n        evmModule,\n        chain,\n        walletClient,\n        config,\n      }),\n    };\n  }, [walletClient, evmModules, chainId, config]);\n\n  return evmSettlementLayer;\n};\n\nexport default useEvmSettlementLayer;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/useSettlementLayerImplementation.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/env.ts",
      "content": "import { createEnv } from '@t3-oss/env-nextjs';\nimport { z } from 'zod';\n\nexport const evmSettlementLayerEnv = () =>\n  createEnv({\n    client: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: z.string().optional(),\n      NEXT_PUBLIC_INDEXER_URL: z.string().default('http://localhost:8080/v1/graphql'),\n    },\n    experimental__runtimeEnv: {\n      NEXT_PUBLIC_WEB3AUTH_CLIENT_ID: process.env.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID,\n      NEXT_PUBLIC_INDEXER_URL: process.env.NEXT_PUBLIC_INDEXER_URL,\n    },\n    emptyStringAsUndefined: true,\n  });\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/env.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/config.type.ts",
      "content": "import { FundsetSettlementLayer } from '@/payload-types';\n\nexport type EvmSettlementLayerConfig = Extract<\n  NonNullable<FundsetSettlementLayer['settlementLayer']>[number],\n  { type: 'evm' }\n>;\n\nexport type EvmModule = {\n  proxyAddress: string;\n  contracts: EvmContracts;\n};\n\nexport type EvmChainModules = Record<number, EvmModule>;\n\ntype ModulesWithContracts = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { contracts: object }\n>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\nexport type EvmContracts = UnionToIntersection<\n  ModulesWithContracts extends infer M\n    ? M extends { contracts: infer C }\n      ? C extends Array<infer T>\n        ? Omit<T, 'id'>\n        : never\n      : never\n    : never\n>;\n\nexport type EvmAccountAbstractionModule = Extract<\n  EvmSettlementLayerConfig['chainConfigs'][number]['modules'][number],\n  { blockType: 'evm-aa-module' }\n>;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/config.type.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/helpers.ts",
      "content": "import { evmSettlementLayerEnv } from './env';\nimport { graphql } from 'gql.tada';\nimport { request } from 'graphql-request';\n\nconst env = evmSettlementLayerEnv();\n\nexport const isTransactionIndexed = async (hash: string) => {\n  const isTransactionIndexedQuery = graphql(`\n    query IsTransactionIndexed($hash: String!) {\n      raw_events(where: { transaction_fields: { _cast: { String: { _iregex: $hash } } } }) {\n        transaction_fields\n        serial\n      }\n    }\n  `);\n  const isTransactionIndexedResult = await request(\n    env.NEXT_PUBLIC_INDEXER_URL,\n    isTransactionIndexedQuery,\n    {\n      hash,\n    },\n  );\n  return isTransactionIndexedResult.raw_events.length > 0;\n};\n\n/**\n * Check if a transaction is indexed by the indexer. It tries to fetch the transaction 8 times with a 1 second delay, if not found during this time, it returns false.\n * @param hash transaction hash to check\n */\nexport const waitForTransactionToBeIndexed = async (hash: string) => {\n  for (let i = 0; i < 8; i++) {\n    try {\n      const isTransactionIndexedResult = await isTransactionIndexed(hash);\n      if (!isTransactionIndexedResult) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        continue;\n      }\n      return true;\n    } catch (error) {\n      console.error('Transaction not indexed', error);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n  return false;\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/helpers.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/index.ts",
      "content": "import type { Config, PayloadRequest } from 'payload';\nimport { EvmSettlementLayer } from './blocks/EvmSettlementLayer';\nimport { seed } from './seed';\n\nexport const evmSettlementLayerPlugin =\n  () =>\n  (config: Config): Config => {\n    config.globals ??= [];\n\n    // append the postgres option to the settlement layer type field\n    const fundsetSettlementLayer = config.globals.find(g => g.slug === 'fundset-settlement-layer');\n\n    if (!fundsetSettlementLayer) {\n      throw new Error(\n        'fundsetSettlementLayer not found, run fundsetBasePlugin before postgresSettlementLayerPlugin',\n      );\n    }\n\n    const settlementLayerTypeField = fundsetSettlementLayer.fields.find(\n      f => f.type === 'blocks' && f.name === 'settlementLayer',\n    )!;\n\n    if (settlementLayerTypeField.type === 'blocks') {\n      settlementLayerTypeField.blocks.push(EvmSettlementLayer);\n    }\n\n    config.endpoints ??= [];\n\n    if (process.env.NODE_ENV === 'development') {\n      config.endpoints.push({\n        path: '/evm/hot-contract-reload',\n        method: 'post',\n        handler: async (req: PayloadRequest) => {\n          const deployedContracts = await req.json?.();\n          await seed(req.payload, deployedContracts, true);\n          return new Response(JSON.stringify({ message: 'OK' }));\n        },\n      });\n    }\n\n    const defaultOnInit = config.onInit;\n\n    config.onInit = async payload => {\n      await defaultOnInit?.(payload);\n\n      const { evmSettlementLayerEnv } = await import('@/_fundset/settlement-layer/evm/env');\n      evmSettlementLayerEnv();\n\n      if (process.env.NODE_ENV === 'development') {\n        await seed(payload);\n      }\n    };\n\n    return config;\n  };\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/seed.ts",
      "content": "import { BasePayload } from 'payload';\nimport { entryPoint07Address } from 'viem/account-abstraction';\nimport type { deploy } from '@fundset/contracts/deploy';\nimport type { FundsetSettlementLayer } from '@/payload-types';\n\nconst waitForContracts = async () => {\n  while (true) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      return require('@fundset/contracts/localhost_deployed_contracts.json') as Awaited<\n        ReturnType<typeof deploy>\n      >;\n    } catch {\n      console.log('Waiting for contracts to be deployed...', 'localhost_deployed_contracts.json');\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n};\n\nexport const seed = async (\n  payload: BasePayload,\n  deployedContracts?: Awaited<ReturnType<typeof deploy>>,\n  replaceExisting = false,\n) => {\n  const localhostDeployments = deployedContracts ?? (await waitForContracts());\n\n  const fundsetSettlementLayer = await payload.findGlobal({\n    slug: 'fundset-settlement-layer',\n  });\n\n  const settlementLayerConfigs = fundsetSettlementLayer.settlementLayer ?? [];\n\n  const evmConfig: FundsetSettlementLayer['settlementLayer'] = [\n    {\n      type: 'evm',\n      blockType: 'evm-settlement-layer',\n      chainConfigs: [\n        {\n          chainId: 31337,\n          rpcUrl: 'http://localhost:8545',\n          proxyAddress: localhostDeployments.DiamondProxy.contract,\n          modules: [\n            {\n              blockType: 'evm-aa-module',\n              bundlerUrl: '/api/bundler',\n              paymasterUrl: 'http://localhost:4338',\n              entryPointAddress: entryPoint07Address,\n              providers: [\n                {\n                  provider: 'google',\n                  mfaLevel: 'default',\n                },\n                {\n                  provider: 'twitter',\n                  mfaLevel: 'default',\n                },\n              ],\n            },\n            {\n              blockType: 'evm-token-module',\n              contracts: [{ token: localhostDeployments.ERC20.contract }],\n            },\n          ],\n        },\n      ],\n    },\n  ];\n\n  let newConfigs;\n  if (replaceExisting) {\n    // Remove all existing evm configs, then add ours\n    const filtered = settlementLayerConfigs.filter(c => c.type !== 'evm');\n    newConfigs = [...filtered, ...evmConfig];\n  } else {\n    // Only add if not present\n    const hasEvm = settlementLayerConfigs.some(c => c?.type === 'evm');\n    newConfigs = hasEvm ? settlementLayerConfigs : [...settlementLayerConfigs, ...evmConfig];\n  }\n\n  await payload.updateGlobal({\n    slug: 'fundset-settlement-layer',\n    data: {\n      settlementLayer: newConfigs.toReversed(),\n    },\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/seed.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts",
      "content": "import type { Block } from 'payload';\n\nconst AaModule: Block = {\n  slug: 'evm-aa-module',\n  dbName: 'aa',\n  fields: [\n    {\n      name: 'paymasterUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'entryPointAddress',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'bundlerUrl',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'providers',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'provider',\n          type: 'select',\n          required: true,\n          options: [\n            'google',\n            'facebook',\n            'reddit',\n            'discord',\n            'twitch',\n            'apple',\n            'line',\n            'github',\n            'kakao',\n            'linkedin',\n            'twitter',\n            'weibo',\n            'wechat',\n            'farcaster',\n            'email_passwordless',\n            'sms_passwordless',\n            'webauthn',\n            'jwt',\n            'passkeys',\n            'authenticator',\n          ].map(provider => ({\n            label: provider.charAt(0).toUpperCase() + provider.slice(1),\n            value: provider,\n          })),\n        },\n        {\n          name: 'mfaLevel',\n          type: 'select',\n          required: true,\n          options: ['default', 'optional', 'mandatory', 'none'].map(mfaLevel => ({\n            label: mfaLevel,\n            value: mfaLevel,\n          })),\n        },\n      ],\n    },\n  ],\n};\n\nconst TokenModule: Block = {\n  slug: 'evm-token-module',\n  fields: [\n    {\n      name: 'contracts',\n      type: 'array',\n      required: true,\n      fields: [\n        {\n          name: 'token',\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n  ],\n};\n\nexport const EvmSettlementLayer: Block = {\n  slug: 'evm-settlement-layer',\n  fields: [\n    {\n      name: 'chainConfigs',\n      required: true,\n      type: 'array',\n      minRows: 1,\n      dbName: 'chainConfigs',\n      fields: [\n        {\n          name: 'rpcUrl',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'chainId',\n          type: 'number',\n          required: true,\n        },\n        {\n          name: 'proxyAddress',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'modules',\n          type: 'blocks',\n          blocks: [AaModule, TokenModule],\n          required: true,\n        },\n      ],\n    },\n    {\n      name: 'type',\n      type: 'select',\n      defaultValue: 'evm',\n      required: true,\n      options: [\n        {\n          label: 'evm',\n          value: 'evm',\n        },\n      ],\n    },\n  ],\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/plugin/blocks/EvmSettlementLayer.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/index.ts",
      "content": "export * from './errorCodes';\nexport * from './decodeMutationError';\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts",
      "content": "export const ERROR_CODES = {\n  TX_REJECTED_BY_USER: 'TX_REJECTED_BY_USER',\n  FAILED_TO_SWITCH_TO_REQUIRED_NETWORK: 'FAILED_TO_SWITCH_TO_REQUIRED_NETWORK',\n  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',\n  CONTRACT_EXECUTION_FAILED: 'CONTRACT_EXECUTION_FAILED',\n  CONTRACT_FUNCTION_REVERTED: 'CONTRACT_FUNCTION_REVERTED',\n  TX_REJECTED_BY_NETWORK: 'TX_REJECTED_BY_NETWORK',\n  TRANSACTION_CONFIRMATION_TIMED_OUT: 'TRANSACTION_CONFIRMATION_TIMED_OUT',\n  RPC_REQUEST_FAILED: 'RPC_REQUEST_FAILED',\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/errorCodes.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts",
      "content": "import { BaseError } from 'wagmi';\nimport {\n  UserRejectedRequestError,\n  SwitchChainError,\n  InsufficientFundsError,\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  RpcRequestError,\n  TransactionRejectedRpcError,\n  WaitForTransactionReceiptTimeoutError,\n  decodeErrorResult,\n} from 'viem';\nimport { ERROR_CODES } from '.';\nimport { UserOperationExecutionError } from 'viem/account-abstraction';\n\nimport * as AllAbis from '@fundset/contracts/abi';\n\nconst ALL_CUSTOM_SOLIDITY_ERRORS = Object.values(AllAbis)\n  .flat()\n  .filter(f => f.type === 'error');\n\n// TODO: handle all errors\nexport const decodeMutationError = (error: Error | null) => {\n  if (!error) return null;\n\n  // Handle wagmi-specific errors\n  if (error instanceof UserRejectedRequestError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_USER, { cause: error });\n  }\n\n  if (error instanceof SwitchChainError) {\n    return new Error(ERROR_CODES.FAILED_TO_SWITCH_TO_REQUIRED_NETWORK, { cause: error });\n  }\n\n  // Handle viem-specific blockchain errors\n  if (error instanceof InsufficientFundsError) {\n    return new Error(ERROR_CODES.INSUFFICIENT_FUNDS, { cause: error });\n  }\n\n  if (error instanceof UserOperationExecutionError) {\n    try {\n      // Handle custom solidity errors\n      const decoded = decodeErrorResult({\n        data: `0x${error.details.split('0x')[1]}`,\n        abi: ALL_CUSTOM_SOLIDITY_ERRORS,\n      });\n      return new Error(decoded.errorName, { cause: error });\n    } catch {\n      // ignore decode errors\n    }\n\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionExecutionError) {\n    return new Error(ERROR_CODES.CONTRACT_EXECUTION_FAILED, { cause: error });\n  }\n\n  if (error instanceof ContractFunctionRevertedError) {\n    return new Error(ERROR_CODES.CONTRACT_FUNCTION_REVERTED, { cause: error });\n  }\n\n  if (error instanceof TransactionRejectedRpcError) {\n    return new Error(ERROR_CODES.TX_REJECTED_BY_NETWORK, { cause: error });\n  }\n\n  if (error instanceof WaitForTransactionReceiptTimeoutError) {\n    return new Error(ERROR_CODES.TRANSACTION_CONFIRMATION_TIMED_OUT, { cause: error });\n  }\n\n  if (error instanceof RpcRequestError) {\n    return new Error(ERROR_CODES.RPC_REQUEST_FAILED, { cause: error });\n  }\n\n  // Handle BaseError (wagmi base class) or generic errors\n  if (error instanceof BaseError || error instanceof Error) {\n    return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n  }\n\n  // Handle unknown errors\n  return new Error(ERROR_CODES.UNKNOWN_ERROR, { cause: error });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/errors/decodeMutationError.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/index.ts",
      "content": "export { SESSION_TIME } from './base';\nexport { LOGIN_PROVIDER, type LOGIN_PROVIDER_TYPE, MFA_LEVELS } from '@web3auth/auth-adapter';\nexport * from './providers';\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/index.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/create.ts",
      "content": "import type { IProvider } from '@web3auth/base';\nimport {\n  createPublicClient,\n  getAddress,\n  http,\n  SwitchChainError,\n  UserRejectedRequestError,\n  type Chain,\n  type EIP1193Provider,\n} from 'viem';\nimport { ChainNotConfiguredError, createConnector } from 'wagmi';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WALLET_ADAPTERS } from '@web3auth/base';\nimport { toKernelSmartAccount } from 'permissionless/accounts';\nimport { createSmartAccountClient, type SmartAccountClient } from 'permissionless';\nimport { type Web3AuthConnectorParams } from '@web3auth/web3auth-wagmi-connector';\nimport { entryPoint07Address } from 'viem/account-abstraction';\nimport { createPimlicoClient } from 'permissionless/clients/pimlico';\nimport type { EvmAccountAbstractionModule } from '../../config.type';\nimport { Web3AuthNoModalConnectorConfig } from './base';\n\ntype SmartAccountConnector = ReturnType<\n  Parameters<typeof createConnector<SmartAccountClient>>[0]\n> & {\n  getEoaProvider: () => Promise<IProvider>;\n  getSmartAccountProvider: (eoaProvider: IProvider) => Promise<SmartAccountClient>;\n};\n\nconst isConnecting = new Map<string, boolean>();\n// this is used to not initialize the login popup immediately when the connector is created,\n// because wagmi config tries to call getProvider on all connectors\nconst isConnected = new Map<string, boolean>();\n\nexport const createWeb3AuthConnector = (\n  parameters: Web3AuthConnectorParams & {\n    accountAbstractionConfigs: (EvmAccountAbstractionModule & { chainId: number })[];\n    icon?: string;\n    whiteLabel?: Web3AuthNoModalConnectorConfig['whiteLabel'];\n  },\n) => {\n  const { web3AuthInstance, loginParams, id, name, type, accountAbstractionConfigs, icon } =\n    parameters;\n\n  let eoaWalletProvider: IProvider | null = null;\n  let smartAccountProvider: SmartAccountClient | null = null;\n\n  return createConnector<SmartAccountClient>(config => ({\n    id: id || 'web3auth',\n    name: name || 'Web3Auth',\n    type: type || 'Web3Auth',\n    icon,\n    async connect({ chainId } = {}) {\n      if (isConnecting.get(id!)) {\n        throw new Error('Already connecting');\n      }\n      isConnecting.set(id!, true);\n      try {\n        config.emitter.emit('message', {\n          type: 'connecting',\n        });\n\n        const provider = await (this as SmartAccountConnector).getEoaProvider();\n\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect.bind(this));\n\n        if (!web3AuthInstance.connected) {\n          if (loginParams) {\n            await web3AuthInstance.connectTo(WALLET_ADAPTERS.AUTH, loginParams);\n          } else {\n            console.error('please provide valid loginParams when using @web3auth/no-modal');\n            throw new UserRejectedRequestError(\n              'please provide valid loginParams when using @web3auth/no-modal' as unknown as Error,\n            );\n          }\n        }\n\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch(error => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return { id: currentChainId };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n\n        const accounts = await this.getAccounts();\n        isConnected.set(id!, true);\n        return { accounts, chainId: currentChainId };\n      } catch (error) {\n        console.error('error while connecting', error);\n        this.onDisconnect();\n        throw new UserRejectedRequestError('Something went wrong' as unknown as Error);\n      } finally {\n        isConnecting.set(id!, false);\n      }\n    },\n    async getAccounts() {\n      const scProvider = await (this as SmartAccountConnector).getSmartAccountProvider(\n        await (this as SmartAccountConnector).getEoaProvider(),\n      );\n      if (!scProvider) {\n        throw new Error('Smart Account Provider not found');\n      }\n      return [scProvider.account!.address];\n    },\n    async getChainId() {\n      const provider = await (this as SmartAccountConnector).getEoaProvider();\n      const chainId = await provider.request<unknown, number>({ method: 'eth_chainId' });\n      return Number(chainId);\n    },\n    async getProvider(): Promise<SmartAccountClient> {\n      if (isConnected.get(id!)) {\n        return (this as SmartAccountConnector).getSmartAccountProvider(\n          await (this as SmartAccountConnector).getEoaProvider(),\n        );\n      }\n      return undefined as unknown as SmartAccountClient;\n    },\n    async getClient() {\n      return this.getProvider();\n    },\n    async getEoaProvider() {\n      if (eoaWalletProvider) {\n        return eoaWalletProvider;\n      }\n      if (web3AuthInstance.status === ADAPTER_STATUS.NOT_READY) {\n        if (loginParams) {\n          await web3AuthInstance.init();\n        } else {\n          console.error('please provide valid loginParams when using @web3auth/no-modal');\n          throw new UserRejectedRequestError(\n            'please provide valid loginParams when using @web3auth/no-modal' as unknown as Error,\n          );\n        }\n      }\n\n      eoaWalletProvider = web3AuthInstance.provider!;\n      return eoaWalletProvider;\n    },\n    async getSmartAccountProvider(eoaProvider: IProvider) {\n      const currentChainId = await this.getChainId();\n\n      // Check if we need to recreate the provider for a different chain\n      if (smartAccountProvider && smartAccountProvider.chain?.id === currentChainId) {\n        return smartAccountProvider;\n      }\n\n      const selectedChain = config.chains.find(x => x.id === currentChainId);\n      if (!selectedChain) {\n        throw new Error(`Chain ${currentChainId} not found`);\n      }\n      const publicClient = createPublicClient({\n        chain: selectedChain,\n        transport: http(config.transports?.[currentChainId]?.({}).value?.url),\n      });\n\n      const simpleSmartAccount = await toKernelSmartAccount({\n        owners: [eoaProvider as EIP1193Provider],\n        client: publicClient,\n        entryPoint: {\n          address: entryPoint07Address,\n          version: '0.7',\n        },\n        index: 0n,\n      });\n\n      const accountAbstractionChainConfig = accountAbstractionConfigs.find(\n        x => x.chainId === currentChainId,\n      );\n\n      if (!accountAbstractionChainConfig) {\n        throw new Error(`Account abstraction module not found for chain ${currentChainId}`);\n      }\n\n      const paymasterClient = createPimlicoClient({\n        transport: http(accountAbstractionChainConfig.paymasterUrl),\n        entryPoint: {\n          address: entryPoint07Address,\n          version: '0.7',\n        },\n      });\n\n      const smartAccountClient = createSmartAccountClient({\n        bundlerTransport: http(accountAbstractionChainConfig.bundlerUrl),\n        chain: selectedChain,\n        account: simpleSmartAccount,\n        paymaster: paymasterClient,\n        userOperation: {\n          estimateFeesPerGas: async () => (await paymasterClient.getUserOperationGasPrice()).fast,\n        },\n      });\n\n      smartAccountProvider = smartAccountClient;\n\n      return smartAccountClient;\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({ chainId }): Promise<Chain> {\n      try {\n        const chain = config.chains.find(x => x.id === chainId);\n        if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n\n        await web3AuthInstance.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId: `0x${chain.id.toString(16)}`,\n          rpcTarget: chain.rpcUrls.default.http[0]!,\n          displayName: chain.name,\n          blockExplorerUrl: chain.blockExplorers?.default.url || '',\n          ticker: chain.nativeCurrency?.symbol || 'ETH',\n          tickerName: chain.nativeCurrency?.name || 'Ethereum',\n          decimals: chain.nativeCurrency?.decimals || 18,\n          logo: chain.nativeCurrency?.symbol\n            ? `https://images.toruswallet.io/${chain.nativeCurrency?.symbol.toLowerCase()}.svg`\n            : 'https://images.toruswallet.io/eth.svg',\n        });\n        console.info('Chain Added: ', chain.name);\n        await web3AuthInstance.switchChain({ chainId: `0x${chain.id.toString(16)}` });\n        console.info('Chain Switched to ', chain.name);\n        config.emitter.emit('change', {\n          chainId,\n        });\n        return chain;\n      } catch (error: unknown) {\n        console.error('Error: Cannot change chain', error);\n        throw new SwitchChainError(error as Error);\n      }\n    },\n    async disconnect(): Promise<void> {\n      isConnected.set(id!, false);\n      await web3AuthInstance.logout();\n      const provider = await (this as SmartAccountConnector).getEoaProvider();\n      provider.removeListener('accountsChanged', this.onAccountsChanged);\n      provider.removeListener('chainChanged', this.onChainChanged);\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) config.emitter.emit('disconnect');\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map(x => getAddress(x)),\n        });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', { chainId });\n    },\n    onDisconnect(): void {\n      config.emitter.emit('disconnect');\n    },\n  }));\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/create.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/base.ts",
      "content": "import { Web3AuthNoModal } from '@web3auth/no-modal';\nimport { EthereumPrivateKeyProvider } from '@web3auth/ethereum-provider';\nimport { CHAIN_NAMESPACES, WEB3AUTH_NETWORK } from '@web3auth/base';\nimport { hardhat } from 'wagmi/chains';\n\nimport {\n  AuthAdapter,\n  type LANGUAGE_TYPE,\n  type LOGIN_PROVIDER_TYPE,\n  type MfaLevelType,\n} from '@web3auth/auth-adapter';\nimport { createWeb3AuthConnector } from './create';\nimport type { EvmAccountAbstractionModule } from '../../config.type';\nimport { evmSettlementLayerEnv } from '../../env';\n\ntype Web3AuthInstanceConfig = {\n  chainId: number;\n  rpcUrl: string;\n  displayName: string;\n  blockExplorerUrl?: string;\n};\n\nexport const SESSION_TIME = 1000 * 60 * 60 * 24 * 7; // 7 days\n\nconst getWeb3AuthInstance = ({\n  chainId,\n  rpcUrl,\n  displayName,\n  blockExplorerUrl,\n}: Web3AuthInstanceConfig) => {\n  const clientId = evmSettlementLayerEnv().NEXT_PUBLIC_WEB3AUTH_CLIENT_ID;\n  if (!clientId) {\n    throw new Error('NEXT_PUBLIC_WEB3AUTH_CLIENT_ID is not set');\n  }\n\n  const chainConfig = {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    chainId: '0x' + chainId.toString(16),\n    rpcTarget: rpcUrl,\n    displayName,\n    tickerName: hardhat.nativeCurrency?.name,\n    ticker: hardhat.nativeCurrency?.symbol,\n    blockExplorerUrl: blockExplorerUrl,\n    logo: 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=040',\n  };\n\n  const privateKeyProvider = new EthereumPrivateKeyProvider({ config: { chainConfig } });\n\n  const web3AuthInstance = new Web3AuthNoModal({\n    clientId,\n    chainConfig,\n    privateKeyProvider,\n    web3AuthNetwork: WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,\n  });\n\n  return web3AuthInstance;\n};\n\nexport type Web3AuthNoModalConnectorConfig = {\n  whiteLabel?: {\n    logoLight: string;\n    logoDark: string;\n    defaultLanguage: LANGUAGE_TYPE;\n    appName: string;\n    theme: {\n      primary: string;\n      onPrimary: string;\n    };\n    mode: 'dark' | 'light';\n    appUrl: string;\n  };\n  loginParams?: {\n    loginProvider: LOGIN_PROVIDER_TYPE;\n    mfaLevel: MfaLevelType;\n  };\n};\n\nconst capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const createWeb3AuthNoModalConnector = (\n  props: Web3AuthInstanceConfig &\n    Web3AuthNoModalConnectorConfig & {\n      accountAbstractionConfigs: (EvmAccountAbstractionModule & { chainId: number })[];\n    },\n) => {\n  const web3AuthInstance = getWeb3AuthInstance(props);\n\n  const clientId = evmSettlementLayerEnv().NEXT_PUBLIC_WEB3AUTH_CLIENT_ID;\n  if (!clientId) {\n    throw new Error('NEXT_PUBLIC_WEB3AUTH_CLIENT_ID is not set');\n  }\n\n  const authAdapter = new AuthAdapter({\n    sessionTime: SESSION_TIME,\n    adapterSettings: {\n      clientId,\n      network: 'testnet',\n      uxMode: 'popup',\n      whiteLabel: props.whiteLabel ?? {\n        logoLight: 'https://codefunded.com/images/codefunded-logo-default.svg',\n        logoDark: 'https://codefunded.com/images/codefunded-logo-dark.svg',\n        defaultLanguage: 'en',\n        appName: 'CodeFunded',\n        theme: {\n          primary: '#FF4A14',\n          onPrimary: '#1C1E1D',\n        },\n        mode: 'dark',\n        appUrl: 'https://codefunded.com',\n      },\n    },\n  });\n  web3AuthInstance.configureAdapter(authAdapter);\n\n  return createWeb3AuthConnector({\n    web3AuthInstance,\n    id: `web3auth-${props.loginParams?.loginProvider}`,\n    name: capitalize(props.loginParams?.loginProvider ?? ''),\n    loginParams: {\n      loginProvider: props.loginParams?.loginProvider ?? 'google',\n      curve: 'secp256k1',\n      mfaLevel: props.loginParams?.mfaLevel ?? 'none',\n    },\n    accountAbstractionConfigs: props.accountAbstractionConfigs,\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/base.ts"
    },
    {
      "path": "../web/src/_fundset/settlement-layer/evm/connectors/web3auth/providers/index.ts",
      "content": "import type { LOGIN_PROVIDER_TYPE } from '@web3auth/auth-adapter';\nimport { createWeb3AuthNoModalConnector } from '../base';\nimport type { EvmSettlementLayerConfig } from '../../../config.type';\nimport { Chain } from 'wagmi/chains';\n\nexport type SocialConnectorParams = {\n  chains: Chain[];\n  chainConfigs: EvmSettlementLayerConfig['chainConfigs'];\n  selectedChainId: number;\n  provider: LOGIN_PROVIDER_TYPE;\n  customRpcUrl?: string;\n};\n\nexport const getWeb3AuthConnector = ({\n  chains,\n  chainConfigs,\n  selectedChainId,\n  provider,\n  customRpcUrl,\n}: SocialConnectorParams) => {\n  const selectedChain = chains.find(chain => chain.id === selectedChainId);\n  if (!selectedChain) {\n    throw new Error(`Chain ${selectedChainId} not found`);\n  }\n\n  const accountAbstractionConfigs = chainConfigs\n    .map(chainConfig => ({\n      chainId: chainConfig.chainId,\n      aaModule: chainConfig.modules.find(module => module.blockType === 'evm-aa-module'),\n    }))\n    .filter(aaConfig => aaConfig.aaModule)\n    .map(aaConfig => ({\n      chainId: aaConfig.chainId,\n      paymasterUrl: aaConfig.aaModule!.paymasterUrl,\n      entryPointAddress: aaConfig.aaModule!.entryPointAddress,\n      bundlerUrl: aaConfig.aaModule!.bundlerUrl,\n      providers: aaConfig.aaModule!.providers,\n      blockType: 'evm-aa-module' as const,\n    }));\n\n  const chainConfig = chainConfigs.find(chainConfig => chainConfig.chainId === selectedChainId);\n\n  const accountAbstractionChainConfig = chainConfig?.modules.find(\n    module => module.blockType === 'evm-aa-module',\n  );\n  if (!accountAbstractionChainConfig) {\n    throw new Error(`Account abstraction module not found for chain ${selectedChainId}`);\n  }\n\n  const providerConfig = accountAbstractionChainConfig.providers.find(p => p.provider === provider);\n  if (!providerConfig) {\n    throw new Error(`Provider ${provider} not found`);\n  }\n\n  return createWeb3AuthNoModalConnector({\n    chainId: selectedChainId,\n    rpcUrl: customRpcUrl || selectedChain.rpcUrls.default.http[0],\n    displayName: selectedChain.name,\n    loginParams: { loginProvider: provider, mfaLevel: providerConfig.mfaLevel },\n    accountAbstractionConfigs,\n  });\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/_fundset/settlement-layer/evm/connectors/web3auth/providers/index.ts"
    },
    {
      "path": "../web/src/features/auth/evm/index.tsx",
      "content": "'use client';\n\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { withClientOnly } from '@/components/utils/client-only';\nimport { ConnectWalletButton } from './components/simplekit';\nimport { useReconnectWeb3Auth } from './useReconnectWeb3Auth';\nimport { useSwitchChainIfSelectedIsNotConfigured } from './useSwitchChainIfSelectedIsNotConfigured';\n\nconst EvmAuthComponentSkeleton = () => (\n  <div className=\"flex flex-col items-center gap-2\">\n    <Skeleton className=\"h-9 w-[100px]\" />\n  </div>\n);\n\nconst EvmAuthComponent = withClientOnly(\n  () => {\n    useReconnectWeb3Auth();\n    useSwitchChainIfSelectedIsNotConfigured();\n\n    return <ConnectWalletButton />;\n  },\n  () => <EvmAuthComponentSkeleton />,\n);\n\nexport default EvmAuthComponent;\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/index.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/useReconnectWeb3Auth.ts",
      "content": "'use client';\n\nimport { useEvmChainConfigs } from '@/_fundset/settlement-layer/evm';\nimport {\n  getWeb3AuthConnector,\n  LOGIN_PROVIDER_TYPE,\n  SESSION_TIME,\n} from '@/_fundset/settlement-layer/evm';\nimport { useLocalStorage } from '@uidotdev/usehooks';\nimport { useEffect, useLayoutEffect } from 'react';\nimport { useAccountEffect, useChainId, useConfig, useConnect } from 'wagmi';\nimport { Chain } from 'wagmi/chains';\n\nconst useConnections = () => {\n  const CURRENT_VERSION = 1;\n  const [connections, setConnections] = useLocalStorage('fundset.connections', {\n    state: { chainId: 0, current: null, connections: { value: [] } },\n    version: CURRENT_VERSION,\n  } as {\n    version: number;\n    state: {\n      chainId: number;\n      current: string | null;\n      connections: {\n        value: [\n          string,\n          {\n            accounts: string[];\n            chainId: number;\n            connector: {\n              id: string;\n              name: string;\n              type: string;\n              uid: string;\n            };\n            sessionFinishAt: number;\n          },\n        ][];\n      };\n    };\n  });\n\n  useEffect(\n    function migrateConnectionsToLatestVersionIfNeeded() {\n      if (connections.version !== CURRENT_VERSION) {\n        setConnections({\n          version: CURRENT_VERSION,\n          state: { chainId: 0, current: null, connections: { value: [] } },\n        });\n      }\n    },\n    [connections.version, setConnections],\n  );\n\n  useEffect(\n    function clearConnectionsIfSessionIsExpired() {\n      if (!connections.state.current) {\n        return;\n      }\n      const connection = connections.state.connections.value.find(\n        ([uid]) => uid === connections.state.current,\n      );\n      if (!connection) {\n        return;\n      }\n      if (connection[1].sessionFinishAt < Date.now()) {\n        setConnections(prev => ({\n          ...prev,\n          state: { ...prev.state, current: null, connections: { value: [] } },\n        }));\n      }\n    },\n    [connections.state, setConnections],\n  );\n\n  useAccountEffect({\n    onConnect: account => {\n      setConnections(prev => ({\n        ...prev,\n        state: {\n          ...prev.state,\n          current: account.connector.uid,\n          connections: {\n            value: [\n              [\n                account.connector.uid,\n                {\n                  accounts: [account.address],\n                  chainId: account.chainId,\n                  connector: {\n                    id: account.connector.id,\n                    name: account.connector.name,\n                    type: account.connector.type,\n                    uid: account.connector.uid,\n                  },\n                  sessionFinishAt: Date.now() + SESSION_TIME,\n                },\n              ],\n            ],\n          },\n        },\n      }));\n    },\n    onDisconnect: () => {\n      setConnections(prev => ({\n        ...prev,\n        state: {\n          ...prev.state,\n          current: null,\n          connections: {\n            value: [],\n          },\n        },\n      }));\n    },\n  });\n\n  return connections;\n};\n\nexport const useReconnectWeb3Auth = () => {\n  const connections = useConnections();\n  const { connect } = useConnect();\n  const config = useConfig();\n  const chainId = useChainId();\n  const chainConfigs = useEvmChainConfigs();\n\n  useLayoutEffect(\n    function reconnectWeb3AuthIfIsLoggedIn() {\n      if (!connections.state.current) return;\n      const connector = connections.state.connections.value.at(0)?.[1];\n      if (!connector || connector.connector.type !== 'Web3Auth') return;\n      if (connector.sessionFinishAt < Date.now()) return;\n\n      const lastProvider = connector.connector.id.split('-')[1] as LOGIN_PROVIDER_TYPE;\n\n      connect({\n        connector: getWeb3AuthConnector({\n          chains: config.chains as unknown as Chain[],\n          customRpcUrl: config._internal.transports?.[chainId]?.({}).value?.url,\n          chainConfigs,\n          selectedChainId: chainId,\n          provider: lastProvider,\n        }),\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/useReconnectWeb3Auth.ts"
    },
    {
      "path": "../web/src/features/auth/evm/useSwitchChainIfSelectedIsNotConfigured.ts",
      "content": "'use client';\n\nimport { useConfig, useConnections, useSwitchChain } from 'wagmi';\nimport { useEffect } from 'react';\n\nexport const useSwitchChainIfSelectedIsNotConfigured = () => {\n  const { switchChain } = useSwitchChain();\n  const config = useConfig();\n  const connections = useConnections();\n\n  useEffect(() => {\n    if (connections.length === 0) return;\n    const connection = connections.at(0);\n    const configuredChains = config.chains.map(chain => chain.id);\n\n    if (connection?.chainId && !configuredChains.includes(connection.chainId)) {\n      switchChain({ chainId: configuredChains[0] });\n    }\n  }, [switchChain, connections, config]);\n};\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/useSwitchChainIfSelectedIsNotConfigured.ts"
    },
    {
      "path": "../web/src/features/auth/evm/components/simplekit.tsx",
      "content": "/* eslint-disable @next/next/no-img-element */\n'use client';\n\nimport * as React from 'react';\n\nimport {\n  SimpleKitModal,\n  SimpleKitModalBody,\n  SimpleKitModalContent,\n  SimpleKitModalDescription,\n  SimpleKitModalFooter,\n  SimpleKitModalHeader,\n  SimpleKitModalTitle,\n} from './simplekit-modal';\nimport { Button } from '@/components/ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport {\n  type Connector,\n  useAccount,\n  useConnect,\n  useDisconnect,\n  useEnsAvatar,\n  useEnsName,\n  useBalance,\n  useChains,\n  useChainId,\n  useSwitchChain,\n} from 'wagmi';\nimport { formatEther } from 'viem';\nimport { Check, ChevronDown, ChevronLeft, Copy, RotateCcw } from 'lucide-react';\nimport { ChainLogo } from './chain-logos';\nimport { useTranslations } from 'next-intl';\n\nconst MODAL_CLOSE_DURATION = 320;\n\nconst SimpleKitContext = React.createContext<{\n  pendingConnector: Connector | null;\n  setPendingConnector: React.Dispatch<React.SetStateAction<Connector | null>>;\n  isConnectorError: boolean;\n  setIsConnectorError: React.Dispatch<React.SetStateAction<boolean>>;\n  open: boolean;\n  setOpen: React.Dispatch<React.SetStateAction<boolean>>;\n}>({\n  pendingConnector: null,\n  setPendingConnector: () => null,\n  isConnectorError: false,\n  setIsConnectorError: () => false,\n  open: false,\n  setOpen: () => false,\n});\n\nfunction SimpleKitProvider(props: { children: React.ReactNode }) {\n  const { status, address } = useAccount();\n  const [pendingConnector, setPendingConnector] = React.useState<Connector | null>(null);\n  const [isConnectorError, setIsConnectorError] = React.useState(false);\n  const [open, setOpen] = React.useState(false);\n  const isConnected = address && !pendingConnector;\n\n  React.useEffect(() => {\n    if (status === 'connected' && pendingConnector) {\n      setOpen(false);\n\n      const timeout = setTimeout(() => {\n        setPendingConnector(null);\n        setIsConnectorError(false);\n      }, MODAL_CLOSE_DURATION);\n\n      return () => clearTimeout(timeout);\n    }\n  }, [status, setOpen, pendingConnector, setPendingConnector]);\n\n  return (\n    <SimpleKitContext.Provider\n      value={{\n        pendingConnector,\n        setPendingConnector,\n        isConnectorError,\n        setIsConnectorError,\n        open,\n        setOpen,\n      }}\n    >\n      {props.children}\n      <SimpleKitModal open={open} onOpenChange={setOpen}>\n        <SimpleKitModalContent>{isConnected ? <Account /> : <Connectors />}</SimpleKitModalContent>\n      </SimpleKitModal>\n    </SimpleKitContext.Provider>\n  );\n}\n\nfunction ConnectWalletButton() {\n  const simplekit = useSimpleKit();\n  const { address } = useAccount();\n  const { data: ensName } = useEnsName({ address });\n  const { data: ensAvatar } = useEnsAvatar({ name: ensName! });\n\n  return (\n    <Button onClick={simplekit.toggleModal} className=\"rounded-xl\">\n      {simplekit.isConnected ? (\n        <>\n          {ensAvatar && <img src={ensAvatar} alt=\"ENS Avatar\" />}\n          {address && <span>{ensName ? `${ensName}` : simplekit.formattedAddress}</span>}\n        </>\n      ) : (\n        'Connect Wallet'\n      )}\n    </Button>\n  );\n}\n\nfunction Account() {\n  const { address } = useAccount();\n  const { disconnect } = useDisconnect();\n  const { data: ensName } = useEnsName({ address });\n  const { data: userBalance } = useBalance({ address });\n  const context = React.useContext(SimpleKitContext);\n  const chains = useChains();\n  const selectedChainId = useChainId();\n  const { switchChain, isPending: isSwitching } = useSwitchChain();\n  const t = useTranslations('Auth');\n\n  const formattedAddress = address?.slice(0, 6) + '' + address?.slice(-4);\n  const formattedUserBalace = userBalance?.value\n    ? parseFloat(formatEther(userBalance.value)).toFixed(4)\n    : undefined;\n\n  function handleDisconnect() {\n    context.setOpen(false);\n    setTimeout(() => {\n      disconnect();\n    }, MODAL_CLOSE_DURATION);\n  }\n\n  return (\n    <>\n      <SimpleKitModalHeader>\n        <SimpleKitModalTitle>{t('your_account')}</SimpleKitModalTitle>\n        <SimpleKitModalDescription className=\"sr-only\">\n          Account modal for your connected Web3 wallet.\n        </SimpleKitModalDescription>\n      </SimpleKitModalHeader>\n      <SimpleKitModalBody className=\"h-[280px]\">\n        <div className=\"flex w-full flex-col items-center justify-center gap-8 md:pt-5\">\n          <div className=\"relative flex size-24 items-center justify-center\">\n            <img\n              className=\"rounded-full\"\n              src={`https://avatar.vercel.sh/${address}?size=150`}\n              alt=\"User gradient avatar\"\n            />\n            <div className=\"absolute right-0 -bottom-2\">\n              <DropdownMenu>\n                <DropdownMenuTrigger asChild>\n                  <Button\n                    variant=\"secondary\"\n                    size=\"sm\"\n                    className=\"h-7 gap-1 rounded-full !px-0 !py-0\"\n                    disabled={isSwitching}\n                  >\n                    <ChainLogo key={selectedChainId} chainId={selectedChainId} />\n\n                    <ChevronDown className=\"mr-2 size-4\" />\n                  </Button>\n                </DropdownMenuTrigger>\n                <DropdownMenuContent align=\"end\" className=\"w-48\">\n                  {chains.map(chain => (\n                    <DropdownMenuItem\n                      key={chain.id}\n                      onClick={() => {\n                        if (chain.id !== selectedChainId) {\n                          switchChain({ chainId: chain.id });\n                        }\n                      }}\n                    >\n                      {chain.name}\n                      {chain.id === selectedChainId && <Check className=\"ml-auto size-4\" />}\n                    </DropdownMenuItem>\n                  ))}\n                </DropdownMenuContent>\n              </DropdownMenu>\n            </div>\n          </div>\n\n          <div className=\"space-y-1 px-3.5 text-center sm:px-0\">\n            <div className=\"flex items-center gap-1.5\">\n              <h1 className=\"text-xl font-semibold\">\n                <div>{ensName ? `${ensName}` : formattedAddress}</div>\n              </h1>\n              <CopyAddressButton />\n            </div>\n            <p className=\"text-muted-foreground text-sm text-balance\">\n              {`${formattedUserBalace ?? '0.00'} ETH`}\n            </p>\n          </div>\n\n          <Button className=\"w-full rounded-xl\" onClick={handleDisconnect}>\n            {t('disconnect')}\n          </Button>\n        </div>\n      </SimpleKitModalBody>\n    </>\n  );\n}\n\nfunction Connectors() {\n  const context = React.useContext(SimpleKitContext);\n  const t = useTranslations('Auth');\n  return (\n    <>\n      <SimpleKitModalHeader>\n        <BackChevron />\n        <SimpleKitModalTitle>{context.pendingConnector?.name ?? t('login')}</SimpleKitModalTitle>\n        <SimpleKitModalDescription className=\"sr-only\">\n          {t('login_description')}\n        </SimpleKitModalDescription>\n      </SimpleKitModalHeader>\n      <SimpleKitModalBody>\n        {context.pendingConnector ? <WalletConnecting /> : <WalletOptions />}\n      </SimpleKitModalBody>\n      <SimpleKitModalFooter>\n        <div className=\"h-0\" />\n      </SimpleKitModalFooter>\n    </>\n  );\n}\n\nfunction WalletConnecting() {\n  const context = React.useContext(SimpleKitContext);\n  const t = useTranslations('Errors');\n  const tAuth = useTranslations('Auth');\n\n  return (\n    <div className=\"flex w-full flex-col items-center justify-center gap-9 md:pt-5\">\n      {context.pendingConnector?.icon && (\n        <div className=\"relative flex size-[116px] items-center justify-center rounded-2xl border p-3\">\n          <img\n            src={context.pendingConnector?.icon}\n            alt={context.pendingConnector?.name}\n            className=\"size-full overflow-hidden rounded-2xl\"\n          />\n          {context.isConnectorError ? <RetryConnectorButton /> : null}\n        </div>\n      )}\n\n      <div className=\"space-y-3.5 px-3.5 text-center sm:px-0\">\n        <h1 className=\"text-xl font-semibold\">\n          {context.isConnectorError ? t('UNKNOWN_ERROR') : tAuth('loading')}\n        </h1>\n        <p className=\"text-muted-foreground text-sm text-balance\">\n          {context.isConnectorError\n            ? tAuth('login_error')\n            : tAuth('waiting_for_connector', { connector: context.pendingConnector?.name ?? '' })}\n        </p>\n      </div>\n    </div>\n  );\n}\n\nfunction WalletOptions() {\n  const context = React.useContext(SimpleKitContext);\n  const { connectors, connect } = useConnectors();\n\n  return (\n    <div className=\"flex flex-col gap-3.5\">\n      {connectors.map(connector => (\n        <WalletOption\n          key={connector.id}\n          connector={connector}\n          onClick={() => {\n            context.setIsConnectorError(false);\n            context.setPendingConnector(connector);\n            connect({ connector });\n          }}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction WalletOption(props: { connector: Connector; onClick: () => void }) {\n  return (\n    <Button\n      onClick={props.onClick}\n      size=\"lg\"\n      variant=\"secondary\"\n      className=\"justify-between rounded-xl px-4 py-7 text-base font-semibold\"\n    >\n      <p>{props.connector.name}</p>\n      {props.connector.icon && (\n        <img\n          src={props.connector.icon}\n          alt={props.connector.name}\n          className=\"size-8 overflow-hidden rounded-[6px]\"\n        />\n      )}\n    </Button>\n  );\n}\n\nfunction CopyAddressButton() {\n  const { address } = useAccount();\n  const [copied, setCopied] = React.useState(false);\n\n  React.useEffect(() => {\n    const timeout = setTimeout(() => {\n      if (copied) setCopied(false);\n    }, 1000);\n    return () => clearTimeout(timeout);\n  }, [copied, setCopied]);\n\n  async function handleCopy() {\n    setCopied(true);\n    await navigator.clipboard.writeText(address!);\n  }\n\n  return (\n    <button className=\"text-muted-foreground\" onClick={handleCopy}>\n      {copied ? (\n        <Check className=\"size-4\" strokeWidth={4} />\n      ) : (\n        <Copy className=\"size-4\" strokeWidth={4} />\n      )}\n    </button>\n  );\n}\n\nfunction BackChevron() {\n  const context = React.useContext(SimpleKitContext);\n\n  if (!context.pendingConnector) {\n    return null;\n  }\n\n  function handleClick() {\n    context.setIsConnectorError(false);\n    context.setPendingConnector(null);\n  }\n\n  return (\n    <button\n      className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-[42px] left-[26px] z-50 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-none disabled:pointer-events-none md:top-[26px]\"\n      onClick={handleClick}\n    >\n      <ChevronLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Cancel connection</span>\n    </button>\n  );\n}\n\nfunction RetryConnectorButton() {\n  const context = React.useContext(SimpleKitContext);\n  const { connect } = useConnect({\n    mutation: {\n      onError: () => context.setIsConnectorError(true),\n    },\n  });\n\n  function handleClick() {\n    if (context.pendingConnector) {\n      context.setIsConnectorError(false);\n      connect({ connector: context.pendingConnector });\n    }\n  }\n\n  return (\n    <Button\n      size=\"icon\"\n      variant=\"secondary\"\n      className=\"group bg-muted absolute -right-2 -bottom-2 rounded-full p-1.5 shadow\"\n      onClick={handleClick}\n    >\n      <RotateCcw className=\"size-4 transition-transform group-hover:-rotate-45\" />\n    </Button>\n  );\n}\n\nfunction useConnectors() {\n  const context = React.useContext(SimpleKitContext);\n  const { connect, connectors } = useConnect({\n    mutation: {\n      onError: error => {\n        console.error(error);\n        context.setIsConnectorError(true);\n      },\n    },\n  });\n\n  const sortedConnectors = React.useMemo(() => {\n    let metaMaskConnector: Connector | undefined;\n    let injectedConnector: Connector | undefined;\n\n    const formattedConnectors = connectors.reduce((acc: Array<Connector>, curr) => {\n      switch (curr.id) {\n        case 'metaMaskSDK':\n          metaMaskConnector = {\n            ...curr,\n            icon: 'https://utfs.io/f/be0bd88f-ce87-4cbc-b2e5-c578fa866173-sq4a0b.png',\n          };\n          return acc;\n        case 'metaMask':\n          injectedConnector = {\n            ...curr,\n            icon: 'https://utfs.io/f/be0bd88f-ce87-4cbc-b2e5-c578fa866173-sq4a0b.png',\n          };\n          return acc;\n        case 'safe':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/164ea200-3e15-4a9b-9ce5-a397894c442a-awpd29.png',\n          });\n          return acc;\n        case 'coinbaseWalletSDK':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/53e47f86-5f12-404f-a98b-19dc7b760333-chngxw.png',\n          });\n          return acc;\n        case 'walletConnect':\n          acc.push({\n            ...curr,\n            icon: 'https://utfs.io/f/5bfaa4d1-b872-48a7-9d37-c2517d4fc07a-utlf4g.png',\n          });\n          return acc;\n        default:\n          acc.unshift(curr);\n          return acc;\n      }\n    }, []);\n\n    if (\n      metaMaskConnector &&\n      !formattedConnectors.find(\n        ({ id }) => id === 'io.metamask' || id === 'io.metamask.mobile' || id === 'injected',\n      )\n    ) {\n      return [metaMaskConnector, ...formattedConnectors];\n    }\n\n    if (injectedConnector) {\n      const nonMetaMaskConnectors = formattedConnectors.filter(\n        ({ id }) => id !== 'io.metamask' && id !== 'io.metamask.mobile',\n      );\n      return [injectedConnector, ...nonMetaMaskConnectors];\n    }\n    return formattedConnectors;\n  }, [connectors]);\n\n  return { connectors: sortedConnectors, connect };\n}\n\n/*\n * This hook can be moved to a separate file\n * if desired (src/hooks/use-simple-kit.tsx).\n */\nfunction useSimpleKit() {\n  const { address } = useAccount();\n  const context = React.useContext(SimpleKitContext);\n\n  const isModalOpen = context.open;\n  const isConnected = address && !context.pendingConnector;\n  const formattedAddress = address?.slice(0, 6) + '' + address?.slice(-4);\n\n  function open() {\n    context.setOpen(true);\n  }\n\n  function close() {\n    context.setOpen(false);\n  }\n\n  function toggleModal() {\n    context.setOpen(prevState => !prevState);\n  }\n\n  return {\n    isModalOpen,\n    isConnected,\n    formattedAddress,\n    open,\n    close,\n    toggleModal,\n  };\n}\n\nexport { SimpleKitProvider, ConnectWalletButton, useSimpleKit, SimpleKitContext };\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/simplekit.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/components/simplekit-modal.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@/lib/utils';\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from '@/components/ui/dialog';\nimport {\n  Drawer,\n  DrawerClose,\n  DrawerContent,\n  DrawerDescription,\n  DrawerFooter,\n  DrawerHeader,\n  DrawerTitle,\n  DrawerTrigger,\n} from '@/components/ui/drawer';\nimport { ScrollArea } from '@/components/ui/scroll-area';\n\ninterface BaseProps {\n  children: React.ReactNode;\n}\n\ninterface RootSimpleKitModalProps extends BaseProps {\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n}\n\ninterface SimpleKitModalProps extends BaseProps {\n  className?: string;\n  asChild?: true;\n}\n\nconst desktop = '(min-width: 768px)';\n\nconst SimpleKitModal = ({ children, ...props }: RootSimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModal = isDesktop ? Dialog : Drawer;\n\n  return <SimpleKitModal {...props}>{children}</SimpleKitModal>;\n};\n\nconst SimpleKitModalTrigger = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalTrigger = isDesktop ? DialogTrigger : DrawerTrigger;\n\n  return (\n    <SimpleKitModalTrigger className={className} {...props}>\n      {children}\n    </SimpleKitModalTrigger>\n  );\n};\n\nconst SimpleKitModalClose = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalClose = isDesktop ? DialogClose : DrawerClose;\n\n  return (\n    <SimpleKitModalClose className={className} {...props}>\n      {children}\n    </SimpleKitModalClose>\n  );\n};\n\nconst SimpleKitModalContent = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalContent = isDesktop ? DialogContent : DrawerContent;\n\n  return (\n    <SimpleKitModalContent\n      className={cn(\n        'rounded-t-3xl sm:rounded-3xl md:max-w-[360px] [&>button]:top-[26px] [&>button]:right-[26px]',\n        className,\n      )}\n      onOpenAutoFocus={e => e.preventDefault()}\n      {...props}\n    >\n      {children}\n    </SimpleKitModalContent>\n  );\n};\n\nconst SimpleKitModalDescription = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalDescription = isDesktop ? DialogDescription : DrawerDescription;\n\n  return (\n    <SimpleKitModalDescription className={className} {...props}>\n      {children}\n    </SimpleKitModalDescription>\n  );\n};\n\nconst SimpleKitModalHeader = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalHeader = isDesktop ? DialogHeader : DrawerHeader;\n\n  return (\n    <SimpleKitModalHeader className={cn('space-y-0 pb-6 md:pb-3', className)} {...props}>\n      {children}\n    </SimpleKitModalHeader>\n  );\n};\n\nconst SimpleKitModalTitle = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalTitle = isDesktop ? DialogTitle : DrawerTitle;\n\n  return (\n    <SimpleKitModalTitle className={cn('text-center', className)} {...props}>\n      {children}\n    </SimpleKitModalTitle>\n  );\n};\n\nconst SimpleKitModalBody = ({ className, children, ...props }: SimpleKitModalProps) => {\n  return (\n    <ScrollArea\n      className={cn(\n        'h-[234px] max-h-[300px] px-6 md:-mr-4 md:h-full md:min-h-[260px] md:px-0 md:pr-4',\n        className,\n      )}\n      {...props}\n    >\n      {children}\n    </ScrollArea>\n  );\n};\n\nconst SimpleKitModalFooter = ({ className, children, ...props }: SimpleKitModalProps) => {\n  const isDesktop = useMediaQuery(desktop);\n  const SimpleKitModalFooter = isDesktop ? DialogFooter : DrawerFooter;\n\n  return (\n    <SimpleKitModalFooter className={cn('py-3.5 md:py-0', className)} {...props}>\n      {children}\n    </SimpleKitModalFooter>\n  );\n};\n\nexport {\n  SimpleKitModal,\n  SimpleKitModalTrigger,\n  SimpleKitModalClose,\n  SimpleKitModalContent,\n  SimpleKitModalDescription,\n  SimpleKitModalHeader,\n  SimpleKitModalTitle,\n  SimpleKitModalBody,\n  SimpleKitModalFooter,\n};\n\n/*\n * Hook used to calculate the width of the screen using the\n * MediaQueryListEvent. This can be moved to a separate file\n * if desired (src/hooks/use-media-query.tsx).\n */\nexport function useMediaQuery(query: string) {\n  const [value, setValue] = React.useState(false);\n\n  React.useEffect(() => {\n    function onChange(event: MediaQueryListEvent) {\n      setValue(event.matches);\n    }\n\n    const result = matchMedia(query);\n    result.addEventListener('change', onChange);\n    setValue(result.matches);\n\n    return () => result.removeEventListener('change', onChange);\n  }, [query]);\n\n  return value;\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/simplekit-modal.tsx"
    },
    {
      "path": "../web/src/features/auth/evm/components/chain-logos.tsx",
      "content": "import React from 'react';\nimport { useChains } from 'wagmi';\n\nconst KnownChain = ({ ...props }: React.SVGProps<SVGSVGElement>) => (\n  <svg\n    {...props}\n    aria-hidden=\"true\"\n    width=\"44\"\n    height=\"44\"\n    viewBox=\"0 0 44 44\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    style={{\n      background: 'linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)',\n    }}\n  >\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M20.5611 8.12948C21.0082 7.90729 21.5007 7.79167 22 7.79167C22.4993 7.79167 22.9919 7.90729 23.439 8.12948L23.4408 8.1304L33.0387 12.9293C33.577 13.197 34.031 13.61 34.3478 14.121C34.6649 14.6323 34.833 15.2218 34.8333 15.8234V27.2595C34.833 27.8611 34.6649 28.4511 34.3478 28.9624C34.031 29.4733 33.578 29.8858 33.0398 30.1535L23.4411 34.9528C22.9919 35.1775 22.4963 35.2947 21.994 35.2947C21.4918 35.2947 20.9964 35.1777 20.5472 34.9529L10.9475 30.1531L10.9452 30.1519C10.4071 29.8808 9.95535 29.4646 9.6411 28.9504C9.32739 28.437 9.16312 27.8464 9.16673 27.2448L9.16675 27.2417L10.0004 27.2475H9.16673V27.2448V15.8239C9.16705 15.2223 9.33518 14.6322 9.65222 14.121C9.96906 13.61 10.4221 13.1976 10.9604 12.9298L20.5592 8.1304L20.5611 8.12948ZM21.3031 9.62267L11.8706 14.3389L22 19.4036L32.1294 14.3389L22.697 9.62267C22.4806 9.51531 22.2416 9.45905 22 9.45905C21.7585 9.45905 21.5194 9.51534 21.3031 9.62267ZM10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241ZM22.8337 33.3923L32.2967 28.6608C32.5576 28.5312 32.7772 28.3313 32.9308 28.0836C33.0844 27.836 33.1658 27.5504 33.166 27.259V15.8243C33.1659 15.7786 33.1639 15.7331 33.1599 15.6878L22.8337 20.8509V33.3923Z\"\n      fill=\"url(#paint0_linear_3546_7073)\"\n    />\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241Z\"\n      fill=\"url(#paint1_linear_3546_7073)\"\n      fillOpacity=\"0.3\"\n    />\n    <defs>\n      <linearGradient\n        id=\"paint0_linear_3546_7073\"\n        x1=\"22\"\n        y1=\"7.79167\"\n        x2=\"22\"\n        y2=\"35.2947\"\n        gradientUnits=\"userSpaceOnUse\"\n      >\n        <stop stopColor=\"white\" />\n        <stop offset=\"1\" stopColor=\"white\" stopOpacity=\"0.7\" />\n      </linearGradient>\n      <linearGradient\n        id=\"paint1_linear_3546_7073\"\n        x1=\"22\"\n        y1=\"7.79167\"\n        x2=\"22\"\n        y2=\"35.2947\"\n        gradientUnits=\"userSpaceOnUse\"\n      >\n        <stop stopColor=\"white\" />\n        <stop offset=\"1\" stopColor=\"white\" stopOpacity=\"0.7\" />\n      </linearGradient>\n    </defs>\n  </svg>\n);\n\nexport function ChainLogo({\n  chainId,\n  size = 28,\n  title,\n  style,\n}: {\n  chainId: number;\n  size?: number;\n  title?: string;\n  style?: React.CSSProperties;\n}) {\n  const chains = useChains();\n  const chain = chains.find(chain => chain.id === chainId);\n  const [srcIndex, setSrcIndex] = React.useState<number>(0);\n\n  const urls = [\n    chain?.name.toLowerCase(),\n    chain?.name.split(' ').join('').toLowerCase(),\n    chain?.name.split(' ').slice(0, 1).join('').toLowerCase(),\n  ]\n    .filter((name, index, arr) => name && arr.indexOf(name) === index) // remove duplicates\n    .map(\n      name =>\n        `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/${name}/info/logo.png`,\n    );\n\n  if (!chain || srcIndex >= urls.length) {\n    return <KnownChain className=\"!h-full !w-7 rounded-full\" />;\n  }\n\n  return (\n    // eslint-disable-next-line @next/next/no-img-element\n    <img\n      src={urls[srcIndex]}\n      alt={title ?? `Chain ${chainId}`}\n      width={size}\n      height={size}\n      style={{ display: 'inline-block', verticalAlign: 'middle', borderRadius: 6, ...style }}\n      onError={() => setSrcIndex(srcIndex => srcIndex + 1)}\n      loading=\"lazy\"\n      decoding=\"async\"\n      className=\"rounded-full\"\n    />\n  );\n}\n",
      "type": "registry:file",
      "target": "~/packages/web/src/features/auth/evm/components/chain-logos.tsx"
    },
    {
      "path": "../evm/indexer/src/EventHandlers.ts",
      "content": "/*\n * Please refer to https://docs.envio.dev for a thorough guide on all Envio indexer features\n */\n\nimport {\n  DiamondProxy,\n  DiamondProxy_DiamondCut,\n  DiamondProxy_OwnershipTransferred,\n} from 'generated';\nimport './modules';\n\nDiamondProxy.DiamondCut.handler(async ({ event, context }) => {\n  for (const facetCut of event.params.facetCuts) {\n    const [facetAddress, action, functionSelectors] = facetCut;\n    const entity: DiamondProxy_DiamondCut = {\n      id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n      diamondAction: action,\n      init: event.params.data,\n      calldata: event.params.data,\n      facetAddress: facetAddress.toString(),\n      functionSelectors: functionSelectors.map(selector => selector.toString()),\n    };\n    context.DiamondProxy_DiamondCut.set(entity);\n  }\n});\n\nDiamondProxy.OwnershipTransferred.handler(async ({ event, context }) => {\n  const entity: DiamondProxy_OwnershipTransferred = {\n    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,\n    newOwner: event.params.newOwner,\n    previousOwner: event.params.previousOwner,\n  };\n  context.DiamondProxy_OwnershipTransferred.set(entity);\n});\n",
      "type": "registry:file",
      "target": "~/packages/evm/indexer/src/EventHandlers.ts"
    }
  ],
  "meta": {
    "dependencies": {
      "web": [
        "zod",
        "@t3-oss/env-nextjs",
        "wagmi",
        "viem",
        "@web3auth/auth-adapter",
        "@web3auth/base",
        "@web3auth/no-modal",
        "@web3auth/ethereum-provider",
        "permissionless",
        "@web3auth/web3auth-wagmi-connector",
        "@uidotdev/usehooks"
      ]
    }
  }
}